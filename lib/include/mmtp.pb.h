// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: mmtp.proto
// Protobuf C++ Version: 5.29.3

#ifndef mmtp_2eproto_2epb_2eh
#define mmtp_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_mmtp_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_mmtp_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_mmtp_2eproto;
class ApplicationMessage;
struct ApplicationMessageDefaultTypeInternal;
extern ApplicationMessageDefaultTypeInternal _ApplicationMessage_default_instance_;
class ApplicationMessageHeader;
struct ApplicationMessageHeaderDefaultTypeInternal;
extern ApplicationMessageHeaderDefaultTypeInternal _ApplicationMessageHeader_default_instance_;
class Connect;
struct ConnectDefaultTypeInternal;
extern ConnectDefaultTypeInternal _Connect_default_instance_;
class Disconnect;
struct DisconnectDefaultTypeInternal;
extern DisconnectDefaultTypeInternal _Disconnect_default_instance_;
class Fetch;
struct FetchDefaultTypeInternal;
extern FetchDefaultTypeInternal _Fetch_default_instance_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class MessageMetadata;
struct MessageMetadataDefaultTypeInternal;
extern MessageMetadataDefaultTypeInternal _MessageMetadata_default_instance_;
class MmtpMessage;
struct MmtpMessageDefaultTypeInternal;
extern MmtpMessageDefaultTypeInternal _MmtpMessage_default_instance_;
class Notify;
struct NotifyDefaultTypeInternal;
extern NotifyDefaultTypeInternal _Notify_default_instance_;
class ProtocolMessage;
struct ProtocolMessageDefaultTypeInternal;
extern ProtocolMessageDefaultTypeInternal _ProtocolMessage_default_instance_;
class Receive;
struct ReceiveDefaultTypeInternal;
extern ReceiveDefaultTypeInternal _Receive_default_instance_;
class Recipients;
struct RecipientsDefaultTypeInternal;
extern RecipientsDefaultTypeInternal _Recipients_default_instance_;
class ResponseMessage;
struct ResponseMessageDefaultTypeInternal;
extern ResponseMessageDefaultTypeInternal _ResponseMessage_default_instance_;
class Send;
struct SendDefaultTypeInternal;
extern SendDefaultTypeInternal _Send_default_instance_;
class Subscribe;
struct SubscribeDefaultTypeInternal;
extern SubscribeDefaultTypeInternal _Subscribe_default_instance_;
class Unsubscribe;
struct UnsubscribeDefaultTypeInternal;
extern UnsubscribeDefaultTypeInternal _Unsubscribe_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum MsgType : int {
  UNSPECIFIED_MESSAGE = 0,
  PROTOCOL_MESSAGE = 1,
  RESPONSE_MESSAGE = 2,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MsgType_IsValid(int value);
extern const uint32_t MsgType_internal_data_[];
constexpr MsgType MsgType_MIN = static_cast<MsgType>(0);
constexpr MsgType MsgType_MAX = static_cast<MsgType>(2);
constexpr int MsgType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
MsgType_descriptor();
template <typename T>
const std::string& MsgType_Name(T value) {
  static_assert(std::is_same<T, MsgType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgType_Name().");
  return MsgType_Name(static_cast<MsgType>(value));
}
template <>
inline const std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MsgType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool MsgType_Parse(absl::string_view name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
      MsgType_descriptor(), name, value);
}
enum ProtocolMessageType : int {
  UNSPECIFIED = 0,
  SUBSCRIBE_MESSAGE = 1,
  UNSUBSCRIBE_MESSAGE = 2,
  SEND_MESSAGE = 3,
  RECEIVE_MESSAGE = 4,
  FETCH_MESSAGE = 5,
  DISCONNECT_MESSAGE = 6,
  CONNECT_MESSAGE = 7,
  NOTIFY_MESSAGE = 8,
  ProtocolMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ProtocolMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ProtocolMessageType_IsValid(int value);
extern const uint32_t ProtocolMessageType_internal_data_[];
constexpr ProtocolMessageType ProtocolMessageType_MIN = static_cast<ProtocolMessageType>(0);
constexpr ProtocolMessageType ProtocolMessageType_MAX = static_cast<ProtocolMessageType>(8);
constexpr int ProtocolMessageType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
ProtocolMessageType_descriptor();
template <typename T>
const std::string& ProtocolMessageType_Name(T value) {
  static_assert(std::is_same<T, ProtocolMessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProtocolMessageType_Name().");
  return ProtocolMessageType_Name(static_cast<ProtocolMessageType>(value));
}
template <>
inline const std::string& ProtocolMessageType_Name(ProtocolMessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ProtocolMessageType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool ProtocolMessageType_Parse(absl::string_view name, ProtocolMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtocolMessageType>(
      ProtocolMessageType_descriptor(), name, value);
}
enum ResponseEnum : int {
  UNSPECIFIED_RESPONSE = 0,
  GOOD = 1,
  ERROR = 2,
  ResponseEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ResponseEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ResponseEnum_IsValid(int value);
extern const uint32_t ResponseEnum_internal_data_[];
constexpr ResponseEnum ResponseEnum_MIN = static_cast<ResponseEnum>(0);
constexpr ResponseEnum ResponseEnum_MAX = static_cast<ResponseEnum>(2);
constexpr int ResponseEnum_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ResponseEnum_descriptor();
template <typename T>
const std::string& ResponseEnum_Name(T value) {
  static_assert(std::is_same<T, ResponseEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResponseEnum_Name().");
  return ResponseEnum_Name(static_cast<ResponseEnum>(value));
}
template <>
inline const std::string& ResponseEnum_Name(ResponseEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ResponseEnum_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ResponseEnum_Parse(absl::string_view name, ResponseEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseEnum>(
      ResponseEnum_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Unsubscribe final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Unsubscribe) */ {
 public:
  inline Unsubscribe() : Unsubscribe(nullptr) {}
  ~Unsubscribe() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Unsubscribe* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Unsubscribe));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Unsubscribe(
      ::google::protobuf::internal::ConstantInitialized);

  inline Unsubscribe(const Unsubscribe& from) : Unsubscribe(nullptr, from) {}
  inline Unsubscribe(Unsubscribe&& from) noexcept
      : Unsubscribe(nullptr, std::move(from)) {}
  inline Unsubscribe& operator=(const Unsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unsubscribe& operator=(Unsubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unsubscribe& default_instance() {
    return *internal_default_instance();
  }
  enum SubjectOrDirectMessagesCase {
    kSubject = 1,
    kDirectMessages = 2,
    SUBJECTORDIRECTMESSAGES_NOT_SET = 0,
  };
  static inline const Unsubscribe* internal_default_instance() {
    return reinterpret_cast<const Unsubscribe*>(
        &_Unsubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Unsubscribe& a, Unsubscribe& b) { a.Swap(&b); }
  inline void Swap(Unsubscribe* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unsubscribe* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Unsubscribe* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Unsubscribe>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Unsubscribe& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Unsubscribe& from) { Unsubscribe::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Unsubscribe* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Unsubscribe"; }

 protected:
  explicit Unsubscribe(::google::protobuf::Arena* arena);
  Unsubscribe(::google::protobuf::Arena* arena, const Unsubscribe& from);
  Unsubscribe(::google::protobuf::Arena* arena, Unsubscribe&& from) noexcept
      : Unsubscribe(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSubjectFieldNumber = 1,
    kDirectMessagesFieldNumber = 2,
  };
  // string subject = 1;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // bool directMessages = 2;
  bool has_directmessages() const;
  void clear_directmessages() ;
  bool directmessages() const;
  void set_directmessages(bool value);

  private:
  bool _internal_directmessages() const;
  void _internal_set_directmessages(bool value);

  public:
  void clear_subjectOrDirectMessages();
  SubjectOrDirectMessagesCase subjectOrDirectMessages_case() const;
  // @@protoc_insertion_point(class_scope:Unsubscribe)
 private:
  class _Internal;
  void set_has_subject();
  void set_has_directmessages();
  inline bool has_subjectOrDirectMessages() const;
  inline void clear_has_subjectOrDirectMessages();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      27, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Unsubscribe& from_msg);
    union SubjectOrDirectMessagesUnion {
      constexpr SubjectOrDirectMessagesUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr subject_;
      bool directmessages_;
    } subjectOrDirectMessages_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Subscribe final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Subscribe) */ {
 public:
  inline Subscribe() : Subscribe(nullptr) {}
  ~Subscribe() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Subscribe* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Subscribe));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Subscribe(
      ::google::protobuf::internal::ConstantInitialized);

  inline Subscribe(const Subscribe& from) : Subscribe(nullptr, from) {}
  inline Subscribe(Subscribe&& from) noexcept
      : Subscribe(nullptr, std::move(from)) {}
  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscribe& operator=(Subscribe&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscribe& default_instance() {
    return *internal_default_instance();
  }
  enum SubjectOrDirectMessagesCase {
    kSubject = 1,
    kDirectMessages = 2,
    SUBJECTORDIRECTMESSAGES_NOT_SET = 0,
  };
  static inline const Subscribe* internal_default_instance() {
    return reinterpret_cast<const Subscribe*>(
        &_Subscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Subscribe& a, Subscribe& b) { a.Swap(&b); }
  inline void Swap(Subscribe* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscribe* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subscribe* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Subscribe>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Subscribe& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Subscribe& from) { Subscribe::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Subscribe* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Subscribe"; }

 protected:
  explicit Subscribe(::google::protobuf::Arena* arena);
  Subscribe(::google::protobuf::Arena* arena, const Subscribe& from);
  Subscribe(::google::protobuf::Arena* arena, Subscribe&& from) noexcept
      : Subscribe(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSubjectFieldNumber = 1,
    kDirectMessagesFieldNumber = 2,
  };
  // string subject = 1;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // bool directMessages = 2;
  bool has_directmessages() const;
  void clear_directmessages() ;
  bool directmessages() const;
  void set_directmessages(bool value);

  private:
  bool _internal_directmessages() const;
  void _internal_set_directmessages(bool value);

  public:
  void clear_subjectOrDirectMessages();
  SubjectOrDirectMessagesCase subjectOrDirectMessages_case() const;
  // @@protoc_insertion_point(class_scope:Subscribe)
 private:
  class _Internal;
  void set_has_subject();
  void set_has_directmessages();
  inline bool has_subjectOrDirectMessages() const;
  inline void clear_has_subjectOrDirectMessages();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      25, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Subscribe& from_msg);
    union SubjectOrDirectMessagesUnion {
      constexpr SubjectOrDirectMessagesUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr subject_;
      bool directmessages_;
    } subjectOrDirectMessages_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Recipients final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Recipients) */ {
 public:
  inline Recipients() : Recipients(nullptr) {}
  ~Recipients() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Recipients* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Recipients));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Recipients(
      ::google::protobuf::internal::ConstantInitialized);

  inline Recipients(const Recipients& from) : Recipients(nullptr, from) {}
  inline Recipients(Recipients&& from) noexcept
      : Recipients(nullptr, std::move(from)) {}
  inline Recipients& operator=(const Recipients& from) {
    CopyFrom(from);
    return *this;
  }
  inline Recipients& operator=(Recipients&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Recipients& default_instance() {
    return *internal_default_instance();
  }
  static inline const Recipients* internal_default_instance() {
    return reinterpret_cast<const Recipients*>(
        &_Recipients_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Recipients& a, Recipients& b) { a.Swap(&b); }
  inline void Swap(Recipients* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Recipients* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Recipients* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Recipients>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Recipients& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Recipients& from) { Recipients::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Recipients* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Recipients"; }

 protected:
  explicit Recipients(::google::protobuf::Arena* arena);
  Recipients(::google::protobuf::Arena* arena, const Recipients& from);
  Recipients(::google::protobuf::Arena* arena, Recipients&& from) noexcept
      : Recipients(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRecipientsFieldNumber = 1,
  };
  // repeated string recipients = 1;
  int recipients_size() const;
  private:
  int _internal_recipients_size() const;

  public:
  void clear_recipients() ;
  const std::string& recipients(int index) const;
  std::string* mutable_recipients(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipients(int index, Arg_&& value, Args_... args);
  std::string* add_recipients();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_recipients(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& recipients() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_recipients();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_recipients() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_recipients();

  public:
  // @@protoc_insertion_point(class_scope:Recipients)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      29, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Recipients& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> recipients_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Filter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Filter* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Filter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Filter(
      ::google::protobuf::internal::ConstantInitialized);

  inline Filter(const Filter& from) : Filter(nullptr, from) {}
  inline Filter(Filter&& from) noexcept
      : Filter(nullptr, std::move(from)) {}
  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
        &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Filter& a, Filter& b) { a.Swap(&b); }
  inline void Swap(Filter* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Filter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Filter& from) { Filter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Filter* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Filter"; }

 protected:
  explicit Filter(::google::protobuf::Arena* arena);
  Filter(::google::protobuf::Arena* arena, const Filter& from);
  Filter(::google::protobuf::Arena* arena, Filter&& from) noexcept
      : Filter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageUuidsFieldNumber = 1,
  };
  // repeated string messageUuids = 1;
  int messageuuids_size() const;
  private:
  int _internal_messageuuids_size() const;

  public:
  void clear_messageuuids() ;
  const std::string& messageuuids(int index) const;
  std::string* mutable_messageuuids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_messageuuids(int index, Arg_&& value, Args_... args);
  std::string* add_messageuuids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_messageuuids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& messageuuids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_messageuuids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_messageuuids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_messageuuids();

  public:
  // @@protoc_insertion_point(class_scope:Filter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      27, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Filter& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> messageuuids_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Fetch final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:Fetch) */ {
 public:
  inline Fetch() : Fetch(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Fetch* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Fetch));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Fetch(
      ::google::protobuf::internal::ConstantInitialized);

  inline Fetch(const Fetch& from) : Fetch(nullptr, from) {}
  inline Fetch(Fetch&& from) noexcept
      : Fetch(nullptr, std::move(from)) {}
  inline Fetch& operator=(const Fetch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fetch& operator=(Fetch&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fetch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fetch* internal_default_instance() {
    return reinterpret_cast<const Fetch*>(
        &_Fetch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Fetch& a, Fetch& b) { a.Swap(&b); }
  inline void Swap(Fetch* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fetch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fetch* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Fetch>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Fetch& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Fetch& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Fetch"; }

 protected:
  explicit Fetch(::google::protobuf::Arena* arena);
  Fetch(::google::protobuf::Arena* arena, const Fetch& from);
  Fetch(::google::protobuf::Arena* arena, Fetch&& from) noexcept
      : Fetch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:Fetch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Fetch& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Disconnect final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:Disconnect) */ {
 public:
  inline Disconnect() : Disconnect(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Disconnect* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Disconnect));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Disconnect(
      ::google::protobuf::internal::ConstantInitialized);

  inline Disconnect(const Disconnect& from) : Disconnect(nullptr, from) {}
  inline Disconnect(Disconnect&& from) noexcept
      : Disconnect(nullptr, std::move(from)) {}
  inline Disconnect& operator=(const Disconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Disconnect& operator=(Disconnect&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Disconnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Disconnect* internal_default_instance() {
    return reinterpret_cast<const Disconnect*>(
        &_Disconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Disconnect& a, Disconnect& b) { a.Swap(&b); }
  inline void Swap(Disconnect* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Disconnect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Disconnect* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Disconnect>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Disconnect& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Disconnect& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Disconnect"; }

 protected:
  explicit Disconnect(::google::protobuf::Arena* arena);
  Disconnect(::google::protobuf::Arena* arena, const Disconnect& from);
  Disconnect(::google::protobuf::Arena* arena, Disconnect&& from) noexcept
      : Disconnect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:Disconnect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Disconnect& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Connect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Connect) */ {
 public:
  inline Connect() : Connect(nullptr) {}
  ~Connect() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Connect* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Connect));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Connect(
      ::google::protobuf::internal::ConstantInitialized);

  inline Connect(const Connect& from) : Connect(nullptr, from) {}
  inline Connect(Connect&& from) noexcept
      : Connect(nullptr, std::move(from)) {}
  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connect& operator=(Connect&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connect* internal_default_instance() {
    return reinterpret_cast<const Connect*>(
        &_Connect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Connect& a, Connect& b) { a.Swap(&b); }
  inline void Swap(Connect* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connect* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Connect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Connect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Connect& from) { Connect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Connect* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Connect"; }

 protected:
  explicit Connect(::google::protobuf::Arena* arena);
  Connect(::google::protobuf::Arena* arena, const Connect& from);
  Connect(::google::protobuf::Arena* arena, Connect&& from) noexcept
      : Connect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOwnMrnFieldNumber = 1,
    kReconnectTokenFieldNumber = 2,
  };
  // optional string ownMrn = 1;
  bool has_ownmrn() const;
  void clear_ownmrn() ;
  const std::string& ownmrn() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ownmrn(Arg_&& arg, Args_... args);
  std::string* mutable_ownmrn();
  PROTOBUF_NODISCARD std::string* release_ownmrn();
  void set_allocated_ownmrn(std::string* value);

  private:
  const std::string& _internal_ownmrn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ownmrn(
      const std::string& value);
  std::string* _internal_mutable_ownmrn();

  public:
  // optional string reconnectToken = 2;
  bool has_reconnecttoken() const;
  void clear_reconnecttoken() ;
  const std::string& reconnecttoken() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reconnecttoken(Arg_&& arg, Args_... args);
  std::string* mutable_reconnecttoken();
  PROTOBUF_NODISCARD std::string* release_reconnecttoken();
  void set_allocated_reconnecttoken(std::string* value);

  private:
  const std::string& _internal_reconnecttoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reconnecttoken(
      const std::string& value);
  std::string* _internal_mutable_reconnecttoken();

  public:
  // @@protoc_insertion_point(class_scope:Connect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      36, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Connect& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ownmrn_;
    ::google::protobuf::internal::ArenaStringPtr reconnecttoken_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Receive final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Receive) */ {
 public:
  inline Receive() : Receive(nullptr) {}
  ~Receive() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Receive* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Receive));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Receive(
      ::google::protobuf::internal::ConstantInitialized);

  inline Receive(const Receive& from) : Receive(nullptr, from) {}
  inline Receive(Receive&& from) noexcept
      : Receive(nullptr, std::move(from)) {}
  inline Receive& operator=(const Receive& from) {
    CopyFrom(from);
    return *this;
  }
  inline Receive& operator=(Receive&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Receive& default_instance() {
    return *internal_default_instance();
  }
  static inline const Receive* internal_default_instance() {
    return reinterpret_cast<const Receive*>(
        &_Receive_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Receive& a, Receive& b) { a.Swap(&b); }
  inline void Swap(Receive* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Receive* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Receive* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Receive>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Receive& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Receive& from) { Receive::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Receive* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Receive"; }

 protected:
  explicit Receive(::google::protobuf::Arena* arena);
  Receive(::google::protobuf::Arena* arena, const Receive& from);
  Receive(::google::protobuf::Arena* arena, Receive&& from) noexcept
      : Receive(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilterFieldNumber = 1,
  };
  // optional .Filter filter = 1;
  bool has_filter() const;
  void clear_filter() ;
  const ::Filter& filter() const;
  PROTOBUF_NODISCARD ::Filter* release_filter();
  ::Filter* mutable_filter();
  void set_allocated_filter(::Filter* value);
  void unsafe_arena_set_allocated_filter(::Filter* value);
  ::Filter* unsafe_arena_release_filter();

  private:
  const ::Filter& _internal_filter() const;
  ::Filter* _internal_mutable_filter();

  public:
  // @@protoc_insertion_point(class_scope:Receive)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Receive& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::Filter* filter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class ApplicationMessageHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ApplicationMessageHeader) */ {
 public:
  inline ApplicationMessageHeader() : ApplicationMessageHeader(nullptr) {}
  ~ApplicationMessageHeader() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApplicationMessageHeader* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApplicationMessageHeader));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApplicationMessageHeader(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApplicationMessageHeader(const ApplicationMessageHeader& from) : ApplicationMessageHeader(nullptr, from) {}
  inline ApplicationMessageHeader(ApplicationMessageHeader&& from) noexcept
      : ApplicationMessageHeader(nullptr, std::move(from)) {}
  inline ApplicationMessageHeader& operator=(const ApplicationMessageHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationMessageHeader& operator=(ApplicationMessageHeader&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationMessageHeader& default_instance() {
    return *internal_default_instance();
  }
  enum SubjectOrRecipientCase {
    kSubject = 1,
    kRecipients = 2,
    SUBJECTORRECIPIENT_NOT_SET = 0,
  };
  static inline const ApplicationMessageHeader* internal_default_instance() {
    return reinterpret_cast<const ApplicationMessageHeader*>(
        &_ApplicationMessageHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ApplicationMessageHeader& a, ApplicationMessageHeader& b) { a.Swap(&b); }
  inline void Swap(ApplicationMessageHeader* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationMessageHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplicationMessageHeader* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ApplicationMessageHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApplicationMessageHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApplicationMessageHeader& from) { ApplicationMessageHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ApplicationMessageHeader* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ApplicationMessageHeader"; }

 protected:
  explicit ApplicationMessageHeader(::google::protobuf::Arena* arena);
  ApplicationMessageHeader(::google::protobuf::Arena* arena, const ApplicationMessageHeader& from);
  ApplicationMessageHeader(::google::protobuf::Arena* arena, ApplicationMessageHeader&& from) noexcept
      : ApplicationMessageHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSenderFieldNumber = 4,
    kQosProfileFieldNumber = 5,
    kExpiresFieldNumber = 3,
    kBodySizeNumBytesFieldNumber = 6,
    kSubjectFieldNumber = 1,
    kRecipientsFieldNumber = 2,
  };
  // string sender = 4;
  void clear_sender() ;
  const std::string& sender() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* value);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // optional string qosProfile = 5;
  bool has_qosprofile() const;
  void clear_qosprofile() ;
  const std::string& qosprofile() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_qosprofile(Arg_&& arg, Args_... args);
  std::string* mutable_qosprofile();
  PROTOBUF_NODISCARD std::string* release_qosprofile();
  void set_allocated_qosprofile(std::string* value);

  private:
  const std::string& _internal_qosprofile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qosprofile(
      const std::string& value);
  std::string* _internal_mutable_qosprofile();

  public:
  // int64 expires = 3;
  void clear_expires() ;
  ::int64_t expires() const;
  void set_expires(::int64_t value);

  private:
  ::int64_t _internal_expires() const;
  void _internal_set_expires(::int64_t value);

  public:
  // uint32 bodySizeNumBytes = 6;
  void clear_bodysizenumbytes() ;
  ::uint32_t bodysizenumbytes() const;
  void set_bodysizenumbytes(::uint32_t value);

  private:
  ::uint32_t _internal_bodysizenumbytes() const;
  void _internal_set_bodysizenumbytes(::uint32_t value);

  public:
  // string subject = 1;
  bool has_subject() const;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // .Recipients recipients = 2;
  bool has_recipients() const;
  private:
  bool _internal_has_recipients() const;

  public:
  void clear_recipients() ;
  const ::Recipients& recipients() const;
  PROTOBUF_NODISCARD ::Recipients* release_recipients();
  ::Recipients* mutable_recipients();
  void set_allocated_recipients(::Recipients* value);
  void unsafe_arena_set_allocated_recipients(::Recipients* value);
  ::Recipients* unsafe_arena_release_recipients();

  private:
  const ::Recipients& _internal_recipients() const;
  ::Recipients* _internal_mutable_recipients();

  public:
  void clear_SubjectOrRecipient();
  SubjectOrRecipientCase SubjectOrRecipient_case() const;
  // @@protoc_insertion_point(class_scope:ApplicationMessageHeader)
 private:
  class _Internal;
  void set_has_subject();
  void set_has_recipients();
  inline bool has_SubjectOrRecipient() const;
  inline void clear_has_SubjectOrRecipient();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 1,
      56, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApplicationMessageHeader& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sender_;
    ::google::protobuf::internal::ArenaStringPtr qosprofile_;
    ::int64_t expires_;
    ::uint32_t bodysizenumbytes_;
    union SubjectOrRecipientUnion {
      constexpr SubjectOrRecipientUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr subject_;
      ::Recipients* recipients_;
    } SubjectOrRecipient_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class MessageMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MessageMetadata) */ {
 public:
  inline MessageMetadata() : MessageMetadata(nullptr) {}
  ~MessageMetadata() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MessageMetadata* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MessageMetadata));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MessageMetadata(
      ::google::protobuf::internal::ConstantInitialized);

  inline MessageMetadata(const MessageMetadata& from) : MessageMetadata(nullptr, from) {}
  inline MessageMetadata(MessageMetadata&& from) noexcept
      : MessageMetadata(nullptr, std::move(from)) {}
  inline MessageMetadata& operator=(const MessageMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageMetadata& operator=(MessageMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageMetadata* internal_default_instance() {
    return reinterpret_cast<const MessageMetadata*>(
        &_MessageMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(MessageMetadata& a, MessageMetadata& b) { a.Swap(&b); }
  inline void Swap(MessageMetadata* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageMetadata* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MessageMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MessageMetadata& from) { MessageMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MessageMetadata* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MessageMetadata"; }

 protected:
  explicit MessageMetadata(::google::protobuf::Arena* arena);
  MessageMetadata(::google::protobuf::Arena* arena, const MessageMetadata& from);
  MessageMetadata(::google::protobuf::Arena* arena, MessageMetadata&& from) noexcept
      : MessageMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUuidFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // string uuid = 1;
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(
      const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // .ApplicationMessageHeader header = 2;
  bool has_header() const;
  void clear_header() ;
  const ::ApplicationMessageHeader& header() const;
  PROTOBUF_NODISCARD ::ApplicationMessageHeader* release_header();
  ::ApplicationMessageHeader* mutable_header();
  void set_allocated_header(::ApplicationMessageHeader* value);
  void unsafe_arena_set_allocated_header(::ApplicationMessageHeader* value);
  ::ApplicationMessageHeader* unsafe_arena_release_header();

  private:
  const ::ApplicationMessageHeader& _internal_header() const;
  ::ApplicationMessageHeader* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:MessageMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      28, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MessageMetadata& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    ::ApplicationMessageHeader* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class ApplicationMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ApplicationMessage) */ {
 public:
  inline ApplicationMessage() : ApplicationMessage(nullptr) {}
  ~ApplicationMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApplicationMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApplicationMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApplicationMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApplicationMessage(const ApplicationMessage& from) : ApplicationMessage(nullptr, from) {}
  inline ApplicationMessage(ApplicationMessage&& from) noexcept
      : ApplicationMessage(nullptr, std::move(from)) {}
  inline ApplicationMessage& operator=(const ApplicationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationMessage& operator=(ApplicationMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplicationMessage* internal_default_instance() {
    return reinterpret_cast<const ApplicationMessage*>(
        &_ApplicationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ApplicationMessage& a, ApplicationMessage& b) { a.Swap(&b); }
  inline void Swap(ApplicationMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplicationMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ApplicationMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApplicationMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApplicationMessage& from) { ApplicationMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ApplicationMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ApplicationMessage"; }

 protected:
  explicit ApplicationMessage(::google::protobuf::Arena* arena);
  ApplicationMessage(::google::protobuf::Arena* arena, const ApplicationMessage& from);
  ApplicationMessage(::google::protobuf::Arena* arena, ApplicationMessage&& from) noexcept
      : ApplicationMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBodyFieldNumber = 2,
    kSignatureFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // bytes body = 2;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // bytes signature = 3;
  void clear_signature() ;
  const std::string& signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* value);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // .ApplicationMessageHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::ApplicationMessageHeader& header() const;
  PROTOBUF_NODISCARD ::ApplicationMessageHeader* release_header();
  ::ApplicationMessageHeader* mutable_header();
  void set_allocated_header(::ApplicationMessageHeader* value);
  void unsafe_arena_set_allocated_header(::ApplicationMessageHeader* value);
  ::ApplicationMessageHeader* unsafe_arena_release_header();

  private:
  const ::ApplicationMessageHeader& _internal_header() const;
  ::ApplicationMessageHeader* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:ApplicationMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApplicationMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::ApplicationMessageHeader* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Send final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Send) */ {
 public:
  inline Send() : Send(nullptr) {}
  ~Send() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Send* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Send));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Send(
      ::google::protobuf::internal::ConstantInitialized);

  inline Send(const Send& from) : Send(nullptr, from) {}
  inline Send(Send&& from) noexcept
      : Send(nullptr, std::move(from)) {}
  inline Send& operator=(const Send& from) {
    CopyFrom(from);
    return *this;
  }
  inline Send& operator=(Send&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Send& default_instance() {
    return *internal_default_instance();
  }
  static inline const Send* internal_default_instance() {
    return reinterpret_cast<const Send*>(
        &_Send_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Send& a, Send& b) { a.Swap(&b); }
  inline void Swap(Send* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Send* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Send* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Send>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Send& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Send& from) { Send::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Send* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Send"; }

 protected:
  explicit Send(::google::protobuf::Arena* arena);
  Send(::google::protobuf::Arena* arena, const Send& from);
  Send(::google::protobuf::Arena* arena, Send&& from) noexcept
      : Send(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kApplicationMessageFieldNumber = 1,
  };
  // .ApplicationMessage applicationMessage = 1;
  bool has_applicationmessage() const;
  void clear_applicationmessage() ;
  const ::ApplicationMessage& applicationmessage() const;
  PROTOBUF_NODISCARD ::ApplicationMessage* release_applicationmessage();
  ::ApplicationMessage* mutable_applicationmessage();
  void set_allocated_applicationmessage(::ApplicationMessage* value);
  void unsafe_arena_set_allocated_applicationmessage(::ApplicationMessage* value);
  ::ApplicationMessage* unsafe_arena_release_applicationmessage();

  private:
  const ::ApplicationMessage& _internal_applicationmessage() const;
  ::ApplicationMessage* _internal_mutable_applicationmessage();

  public:
  // @@protoc_insertion_point(class_scope:Send)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Send& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::ApplicationMessage* applicationmessage_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class ResponseMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ResponseMessage) */ {
 public:
  inline ResponseMessage() : ResponseMessage(nullptr) {}
  ~ResponseMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResponseMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResponseMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResponseMessage(const ResponseMessage& from) : ResponseMessage(nullptr, from) {}
  inline ResponseMessage(ResponseMessage&& from) noexcept
      : ResponseMessage(nullptr, std::move(from)) {}
  inline ResponseMessage& operator=(const ResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseMessage& operator=(ResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseMessage* internal_default_instance() {
    return reinterpret_cast<const ResponseMessage*>(
        &_ResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ResponseMessage& a, ResponseMessage& b) { a.Swap(&b); }
  inline void Swap(ResponseMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResponseMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResponseMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResponseMessage& from) { ResponseMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResponseMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ResponseMessage"; }

 protected:
  explicit ResponseMessage(::google::protobuf::Arena* arena);
  ResponseMessage(::google::protobuf::Arena* arena, const ResponseMessage& from);
  ResponseMessage(::google::protobuf::Arena* arena, ResponseMessage&& from) noexcept
      : ResponseMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageMetadataFieldNumber = 4,
    kApplicationMessagesFieldNumber = 5,
    kResponseToUuidFieldNumber = 1,
    kReasonTextFieldNumber = 3,
    kReconnectTokenFieldNumber = 6,
    kResponseFieldNumber = 2,
  };
  // repeated .MessageMetadata messageMetadata = 4;
  int messagemetadata_size() const;
  private:
  int _internal_messagemetadata_size() const;

  public:
  void clear_messagemetadata() ;
  ::MessageMetadata* mutable_messagemetadata(int index);
  ::google::protobuf::RepeatedPtrField<::MessageMetadata>* mutable_messagemetadata();

  private:
  const ::google::protobuf::RepeatedPtrField<::MessageMetadata>& _internal_messagemetadata() const;
  ::google::protobuf::RepeatedPtrField<::MessageMetadata>* _internal_mutable_messagemetadata();
  public:
  const ::MessageMetadata& messagemetadata(int index) const;
  ::MessageMetadata* add_messagemetadata();
  const ::google::protobuf::RepeatedPtrField<::MessageMetadata>& messagemetadata() const;
  // repeated .ApplicationMessage applicationMessages = 5;
  int applicationmessages_size() const;
  private:
  int _internal_applicationmessages_size() const;

  public:
  void clear_applicationmessages() ;
  ::ApplicationMessage* mutable_applicationmessages(int index);
  ::google::protobuf::RepeatedPtrField<::ApplicationMessage>* mutable_applicationmessages();

  private:
  const ::google::protobuf::RepeatedPtrField<::ApplicationMessage>& _internal_applicationmessages() const;
  ::google::protobuf::RepeatedPtrField<::ApplicationMessage>* _internal_mutable_applicationmessages();
  public:
  const ::ApplicationMessage& applicationmessages(int index) const;
  ::ApplicationMessage* add_applicationmessages();
  const ::google::protobuf::RepeatedPtrField<::ApplicationMessage>& applicationmessages() const;
  // string responseToUuid = 1;
  void clear_responsetouuid() ;
  const std::string& responsetouuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_responsetouuid(Arg_&& arg, Args_... args);
  std::string* mutable_responsetouuid();
  PROTOBUF_NODISCARD std::string* release_responsetouuid();
  void set_allocated_responsetouuid(std::string* value);

  private:
  const std::string& _internal_responsetouuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_responsetouuid(
      const std::string& value);
  std::string* _internal_mutable_responsetouuid();

  public:
  // optional string reasonText = 3;
  bool has_reasontext() const;
  void clear_reasontext() ;
  const std::string& reasontext() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reasontext(Arg_&& arg, Args_... args);
  std::string* mutable_reasontext();
  PROTOBUF_NODISCARD std::string* release_reasontext();
  void set_allocated_reasontext(std::string* value);

  private:
  const std::string& _internal_reasontext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reasontext(
      const std::string& value);
  std::string* _internal_mutable_reasontext();

  public:
  // optional string reconnectToken = 6;
  bool has_reconnecttoken() const;
  void clear_reconnecttoken() ;
  const std::string& reconnecttoken() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reconnecttoken(Arg_&& arg, Args_... args);
  std::string* mutable_reconnecttoken();
  PROTOBUF_NODISCARD std::string* release_reconnecttoken();
  void set_allocated_reconnecttoken(std::string* value);

  private:
  const std::string& _internal_reconnecttoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reconnecttoken(
      const std::string& value);
  std::string* _internal_mutable_reconnecttoken();

  public:
  // .ResponseEnum response = 2;
  void clear_response() ;
  ::ResponseEnum response() const;
  void set_response(::ResponseEnum value);

  private:
  ::ResponseEnum _internal_response() const;
  void _internal_set_response(::ResponseEnum value);

  public:
  // @@protoc_insertion_point(class_scope:ResponseMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      62, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ResponseMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MessageMetadata > messagemetadata_;
    ::google::protobuf::RepeatedPtrField< ::ApplicationMessage > applicationmessages_;
    ::google::protobuf::internal::ArenaStringPtr responsetouuid_;
    ::google::protobuf::internal::ArenaStringPtr reasontext_;
    ::google::protobuf::internal::ArenaStringPtr reconnecttoken_;
    int response_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class Notify final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:Notify) */ {
 public:
  inline Notify() : Notify(nullptr) {}
  ~Notify() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Notify* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Notify));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Notify(
      ::google::protobuf::internal::ConstantInitialized);

  inline Notify(const Notify& from) : Notify(nullptr, from) {}
  inline Notify(Notify&& from) noexcept
      : Notify(nullptr, std::move(from)) {}
  inline Notify& operator=(const Notify& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notify& operator=(Notify&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notify& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notify* internal_default_instance() {
    return reinterpret_cast<const Notify*>(
        &_Notify_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Notify& a, Notify& b) { a.Swap(&b); }
  inline void Swap(Notify* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notify* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notify* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Notify>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Notify& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Notify& from) { Notify::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Notify* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "Notify"; }

 protected:
  explicit Notify(::google::protobuf::Arena* arena);
  Notify(::google::protobuf::Arena* arena, const Notify& from);
  Notify(::google::protobuf::Arena* arena, Notify&& from) noexcept
      : Notify(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageMetadataFieldNumber = 1,
  };
  // repeated .MessageMetadata messageMetadata = 1;
  int messagemetadata_size() const;
  private:
  int _internal_messagemetadata_size() const;

  public:
  void clear_messagemetadata() ;
  ::MessageMetadata* mutable_messagemetadata(int index);
  ::google::protobuf::RepeatedPtrField<::MessageMetadata>* mutable_messagemetadata();

  private:
  const ::google::protobuf::RepeatedPtrField<::MessageMetadata>& _internal_messagemetadata() const;
  ::google::protobuf::RepeatedPtrField<::MessageMetadata>* _internal_mutable_messagemetadata();
  public:
  const ::MessageMetadata& messagemetadata(int index) const;
  ::MessageMetadata* add_messagemetadata();
  const ::google::protobuf::RepeatedPtrField<::MessageMetadata>& messagemetadata() const;
  // @@protoc_insertion_point(class_scope:Notify)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Notify& from_msg);
    ::google::protobuf::RepeatedPtrField< ::MessageMetadata > messagemetadata_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class ProtocolMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ProtocolMessage) */ {
 public:
  inline ProtocolMessage() : ProtocolMessage(nullptr) {}
  ~ProtocolMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ProtocolMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ProtocolMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProtocolMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ProtocolMessage(const ProtocolMessage& from) : ProtocolMessage(nullptr, from) {}
  inline ProtocolMessage(ProtocolMessage&& from) noexcept
      : ProtocolMessage(nullptr, std::move(from)) {}
  inline ProtocolMessage& operator=(const ProtocolMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolMessage& operator=(ProtocolMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kSubscribeMessage = 2,
    kUnsubscribeMessage = 3,
    kSendMessage = 4,
    kReceiveMessage = 5,
    kFetchMessage = 6,
    kDisconnectMessage = 7,
    kConnectMessage = 8,
    kNotifyMessage = 9,
    BODY_NOT_SET = 0,
  };
  static inline const ProtocolMessage* internal_default_instance() {
    return reinterpret_cast<const ProtocolMessage*>(
        &_ProtocolMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ProtocolMessage& a, ProtocolMessage& b) { a.Swap(&b); }
  inline void Swap(ProtocolMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtocolMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ProtocolMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProtocolMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProtocolMessage& from) { ProtocolMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ProtocolMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ProtocolMessage"; }

 protected:
  explicit ProtocolMessage(::google::protobuf::Arena* arena);
  ProtocolMessage(::google::protobuf::Arena* arena, const ProtocolMessage& from);
  ProtocolMessage(::google::protobuf::Arena* arena, ProtocolMessage&& from) noexcept
      : ProtocolMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProtocolMsgTypeFieldNumber = 1,
    kSubscribeMessageFieldNumber = 2,
    kUnsubscribeMessageFieldNumber = 3,
    kSendMessageFieldNumber = 4,
    kReceiveMessageFieldNumber = 5,
    kFetchMessageFieldNumber = 6,
    kDisconnectMessageFieldNumber = 7,
    kConnectMessageFieldNumber = 8,
    kNotifyMessageFieldNumber = 9,
  };
  // .ProtocolMessageType protocolMsgType = 1;
  void clear_protocolmsgtype() ;
  ::ProtocolMessageType protocolmsgtype() const;
  void set_protocolmsgtype(::ProtocolMessageType value);

  private:
  ::ProtocolMessageType _internal_protocolmsgtype() const;
  void _internal_set_protocolmsgtype(::ProtocolMessageType value);

  public:
  // .Subscribe subscribeMessage = 2;
  bool has_subscribemessage() const;
  private:
  bool _internal_has_subscribemessage() const;

  public:
  void clear_subscribemessage() ;
  const ::Subscribe& subscribemessage() const;
  PROTOBUF_NODISCARD ::Subscribe* release_subscribemessage();
  ::Subscribe* mutable_subscribemessage();
  void set_allocated_subscribemessage(::Subscribe* value);
  void unsafe_arena_set_allocated_subscribemessage(::Subscribe* value);
  ::Subscribe* unsafe_arena_release_subscribemessage();

  private:
  const ::Subscribe& _internal_subscribemessage() const;
  ::Subscribe* _internal_mutable_subscribemessage();

  public:
  // .Unsubscribe unsubscribeMessage = 3;
  bool has_unsubscribemessage() const;
  private:
  bool _internal_has_unsubscribemessage() const;

  public:
  void clear_unsubscribemessage() ;
  const ::Unsubscribe& unsubscribemessage() const;
  PROTOBUF_NODISCARD ::Unsubscribe* release_unsubscribemessage();
  ::Unsubscribe* mutable_unsubscribemessage();
  void set_allocated_unsubscribemessage(::Unsubscribe* value);
  void unsafe_arena_set_allocated_unsubscribemessage(::Unsubscribe* value);
  ::Unsubscribe* unsafe_arena_release_unsubscribemessage();

  private:
  const ::Unsubscribe& _internal_unsubscribemessage() const;
  ::Unsubscribe* _internal_mutable_unsubscribemessage();

  public:
  // .Send sendMessage = 4;
  bool has_sendmessage() const;
  private:
  bool _internal_has_sendmessage() const;

  public:
  void clear_sendmessage() ;
  const ::Send& sendmessage() const;
  PROTOBUF_NODISCARD ::Send* release_sendmessage();
  ::Send* mutable_sendmessage();
  void set_allocated_sendmessage(::Send* value);
  void unsafe_arena_set_allocated_sendmessage(::Send* value);
  ::Send* unsafe_arena_release_sendmessage();

  private:
  const ::Send& _internal_sendmessage() const;
  ::Send* _internal_mutable_sendmessage();

  public:
  // .Receive receiveMessage = 5;
  bool has_receivemessage() const;
  private:
  bool _internal_has_receivemessage() const;

  public:
  void clear_receivemessage() ;
  const ::Receive& receivemessage() const;
  PROTOBUF_NODISCARD ::Receive* release_receivemessage();
  ::Receive* mutable_receivemessage();
  void set_allocated_receivemessage(::Receive* value);
  void unsafe_arena_set_allocated_receivemessage(::Receive* value);
  ::Receive* unsafe_arena_release_receivemessage();

  private:
  const ::Receive& _internal_receivemessage() const;
  ::Receive* _internal_mutable_receivemessage();

  public:
  // .Fetch fetchMessage = 6;
  bool has_fetchmessage() const;
  private:
  bool _internal_has_fetchmessage() const;

  public:
  void clear_fetchmessage() ;
  const ::Fetch& fetchmessage() const;
  PROTOBUF_NODISCARD ::Fetch* release_fetchmessage();
  ::Fetch* mutable_fetchmessage();
  void set_allocated_fetchmessage(::Fetch* value);
  void unsafe_arena_set_allocated_fetchmessage(::Fetch* value);
  ::Fetch* unsafe_arena_release_fetchmessage();

  private:
  const ::Fetch& _internal_fetchmessage() const;
  ::Fetch* _internal_mutable_fetchmessage();

  public:
  // .Disconnect disconnectMessage = 7;
  bool has_disconnectmessage() const;
  private:
  bool _internal_has_disconnectmessage() const;

  public:
  void clear_disconnectmessage() ;
  const ::Disconnect& disconnectmessage() const;
  PROTOBUF_NODISCARD ::Disconnect* release_disconnectmessage();
  ::Disconnect* mutable_disconnectmessage();
  void set_allocated_disconnectmessage(::Disconnect* value);
  void unsafe_arena_set_allocated_disconnectmessage(::Disconnect* value);
  ::Disconnect* unsafe_arena_release_disconnectmessage();

  private:
  const ::Disconnect& _internal_disconnectmessage() const;
  ::Disconnect* _internal_mutable_disconnectmessage();

  public:
  // .Connect connectMessage = 8;
  bool has_connectmessage() const;
  private:
  bool _internal_has_connectmessage() const;

  public:
  void clear_connectmessage() ;
  const ::Connect& connectmessage() const;
  PROTOBUF_NODISCARD ::Connect* release_connectmessage();
  ::Connect* mutable_connectmessage();
  void set_allocated_connectmessage(::Connect* value);
  void unsafe_arena_set_allocated_connectmessage(::Connect* value);
  ::Connect* unsafe_arena_release_connectmessage();

  private:
  const ::Connect& _internal_connectmessage() const;
  ::Connect* _internal_mutable_connectmessage();

  public:
  // .Notify notifyMessage = 9;
  bool has_notifymessage() const;
  private:
  bool _internal_has_notifymessage() const;

  public:
  void clear_notifymessage() ;
  const ::Notify& notifymessage() const;
  PROTOBUF_NODISCARD ::Notify* release_notifymessage();
  ::Notify* mutable_notifymessage();
  void set_allocated_notifymessage(::Notify* value);
  void unsafe_arena_set_allocated_notifymessage(::Notify* value);
  ::Notify* unsafe_arena_release_notifymessage();

  private:
  const ::Notify& _internal_notifymessage() const;
  ::Notify* _internal_mutable_notifymessage();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:ProtocolMessage)
 private:
  class _Internal;
  void set_has_subscribemessage();
  void set_has_unsubscribemessage();
  void set_has_sendmessage();
  void set_has_receivemessage();
  void set_has_fetchmessage();
  void set_has_disconnectmessage();
  void set_has_connectmessage();
  void set_has_notifymessage();
  inline bool has_body() const;
  inline void clear_has_body();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 9, 8,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ProtocolMessage& from_msg);
    int protocolmsgtype_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::Subscribe* subscribemessage_;
      ::Unsubscribe* unsubscribemessage_;
      ::Send* sendmessage_;
      ::Receive* receivemessage_;
      ::Fetch* fetchmessage_;
      ::Disconnect* disconnectmessage_;
      ::Connect* connectmessage_;
      ::Notify* notifymessage_;
    } body_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};
// -------------------------------------------------------------------

class MmtpMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MmtpMessage) */ {
 public:
  inline MmtpMessage() : MmtpMessage(nullptr) {}
  ~MmtpMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MmtpMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MmtpMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MmtpMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline MmtpMessage(const MmtpMessage& from) : MmtpMessage(nullptr, from) {}
  inline MmtpMessage(MmtpMessage&& from) noexcept
      : MmtpMessage(nullptr, std::move(from)) {}
  inline MmtpMessage& operator=(const MmtpMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MmtpMessage& operator=(MmtpMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MmtpMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kProtocolMessage = 3,
    kResponseMessage = 4,
    BODY_NOT_SET = 0,
  };
  static inline const MmtpMessage* internal_default_instance() {
    return reinterpret_cast<const MmtpMessage*>(
        &_MmtpMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(MmtpMessage& a, MmtpMessage& b) { a.Swap(&b); }
  inline void Swap(MmtpMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MmtpMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MmtpMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MmtpMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MmtpMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MmtpMessage& from) { MmtpMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MmtpMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MmtpMessage"; }

 protected:
  explicit MmtpMessage(::google::protobuf::Arena* arena);
  MmtpMessage(::google::protobuf::Arena* arena, const MmtpMessage& from);
  MmtpMessage(::google::protobuf::Arena* arena, MmtpMessage&& from) noexcept
      : MmtpMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUuidFieldNumber = 2,
    kMsgTypeFieldNumber = 1,
    kProtocolMessageFieldNumber = 3,
    kResponseMessageFieldNumber = 4,
  };
  // string uuid = 2;
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(
      const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // .MsgType msgType = 1;
  void clear_msgtype() ;
  ::MsgType msgtype() const;
  void set_msgtype(::MsgType value);

  private:
  ::MsgType _internal_msgtype() const;
  void _internal_set_msgtype(::MsgType value);

  public:
  // .ProtocolMessage protocolMessage = 3;
  bool has_protocolmessage() const;
  private:
  bool _internal_has_protocolmessage() const;

  public:
  void clear_protocolmessage() ;
  const ::ProtocolMessage& protocolmessage() const;
  PROTOBUF_NODISCARD ::ProtocolMessage* release_protocolmessage();
  ::ProtocolMessage* mutable_protocolmessage();
  void set_allocated_protocolmessage(::ProtocolMessage* value);
  void unsafe_arena_set_allocated_protocolmessage(::ProtocolMessage* value);
  ::ProtocolMessage* unsafe_arena_release_protocolmessage();

  private:
  const ::ProtocolMessage& _internal_protocolmessage() const;
  ::ProtocolMessage* _internal_mutable_protocolmessage();

  public:
  // .ResponseMessage responseMessage = 4;
  bool has_responsemessage() const;
  private:
  bool _internal_has_responsemessage() const;

  public:
  void clear_responsemessage() ;
  const ::ResponseMessage& responsemessage() const;
  PROTOBUF_NODISCARD ::ResponseMessage* release_responsemessage();
  ::ResponseMessage* mutable_responsemessage();
  void set_allocated_responsemessage(::ResponseMessage* value);
  void unsafe_arena_set_allocated_responsemessage(::ResponseMessage* value);
  ::ResponseMessage* unsafe_arena_release_responsemessage();

  private:
  const ::ResponseMessage& _internal_responsemessage() const;
  ::ResponseMessage* _internal_mutable_responsemessage();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:MmtpMessage)
 private:
  class _Internal;
  void set_has_protocolmessage();
  void set_has_responsemessage();
  inline bool has_body() const;
  inline void clear_has_body();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 2,
      24, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MmtpMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    int msgtype_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::ProtocolMessage* protocolmessage_;
      ::ResponseMessage* responsemessage_;
    } body_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mmtp_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ApplicationMessage

// .ApplicationMessageHeader header = 1;
inline bool ApplicationMessage::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void ApplicationMessage::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ApplicationMessageHeader& ApplicationMessage::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ApplicationMessageHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::ApplicationMessageHeader&>(::_ApplicationMessageHeader_default_instance_);
}
inline const ::ApplicationMessageHeader& ApplicationMessage::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApplicationMessage.header)
  return _internal_header();
}
inline void ApplicationMessage::unsafe_arena_set_allocated_header(::ApplicationMessageHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::ApplicationMessageHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApplicationMessage.header)
}
inline ::ApplicationMessageHeader* ApplicationMessage::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ApplicationMessageHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ApplicationMessageHeader* ApplicationMessage::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApplicationMessage.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ApplicationMessageHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::ApplicationMessageHeader* ApplicationMessage::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ApplicationMessageHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::ApplicationMessageHeader*>(p);
  }
  return _impl_.header_;
}
inline ::ApplicationMessageHeader* ApplicationMessage::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ApplicationMessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:ApplicationMessage.header)
  return _msg;
}
inline void ApplicationMessage::set_allocated_header(::ApplicationMessageHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::ApplicationMessageHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessage.header)
}

// bytes body = 2;
inline void ApplicationMessage::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& ApplicationMessage::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApplicationMessage.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ApplicationMessage::set_body(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ApplicationMessage.body)
}
inline std::string* ApplicationMessage::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:ApplicationMessage.body)
  return _s;
}
inline const std::string& ApplicationMessage::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.body_.Get();
}
inline void ApplicationMessage::_internal_set_body(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* ApplicationMessage::_internal_mutable_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* ApplicationMessage::release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApplicationMessage.body)
  return _impl_.body_.Release();
}
inline void ApplicationMessage::set_allocated_body(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessage.body)
}

// bytes signature = 3;
inline void ApplicationMessage::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& ApplicationMessage::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApplicationMessage.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ApplicationMessage::set_signature(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ApplicationMessage.signature)
}
inline std::string* ApplicationMessage::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:ApplicationMessage.signature)
  return _s;
}
inline const std::string& ApplicationMessage::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_.Get();
}
inline void ApplicationMessage::_internal_set_signature(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.Set(value, GetArena());
}
inline std::string* ApplicationMessage::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signature_.Mutable( GetArena());
}
inline std::string* ApplicationMessage::release_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApplicationMessage.signature)
  return _impl_.signature_.Release();
}
inline void ApplicationMessage::set_allocated_signature(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessage.signature)
}

// -------------------------------------------------------------------

// ApplicationMessageHeader

// string subject = 1;
inline bool ApplicationMessageHeader::has_subject() const {
  return SubjectOrRecipient_case() == kSubject;
}
inline void ApplicationMessageHeader::set_has_subject() {
  _impl_._oneof_case_[0] = kSubject;
}
inline void ApplicationMessageHeader::clear_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (SubjectOrRecipient_case() == kSubject) {
    _impl_.SubjectOrRecipient_.subject_.Destroy();
    clear_has_SubjectOrRecipient();
  }
}
inline const std::string& ApplicationMessageHeader::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ApplicationMessageHeader::set_subject(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (SubjectOrRecipient_case() != kSubject) {
    clear_SubjectOrRecipient();

    set_has_subject();
    _impl_.SubjectOrRecipient_.subject_.InitDefault();
  }
  _impl_.SubjectOrRecipient_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.subject)
}
inline std::string* ApplicationMessageHeader::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:ApplicationMessageHeader.subject)
  return _s;
}
inline const std::string& ApplicationMessageHeader::_internal_subject() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (SubjectOrRecipient_case() != kSubject) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.SubjectOrRecipient_.subject_.Get();
}
inline void ApplicationMessageHeader::_internal_set_subject(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (SubjectOrRecipient_case() != kSubject) {
    clear_SubjectOrRecipient();

    set_has_subject();
    _impl_.SubjectOrRecipient_.subject_.InitDefault();
  }
  _impl_.SubjectOrRecipient_.subject_.Set(value, GetArena());
}
inline std::string* ApplicationMessageHeader::_internal_mutable_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (SubjectOrRecipient_case() != kSubject) {
    clear_SubjectOrRecipient();

    set_has_subject();
    _impl_.SubjectOrRecipient_.subject_.InitDefault();
  }
  return _impl_.SubjectOrRecipient_.subject_.Mutable( GetArena());
}
inline std::string* ApplicationMessageHeader::release_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApplicationMessageHeader.subject)
  if (SubjectOrRecipient_case() != kSubject) {
    return nullptr;
  }
  clear_has_SubjectOrRecipient();
  return _impl_.SubjectOrRecipient_.subject_.Release();
}
inline void ApplicationMessageHeader::set_allocated_subject(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_SubjectOrRecipient()) {
    clear_SubjectOrRecipient();
  }
  if (value != nullptr) {
    set_has_subject();
    _impl_.SubjectOrRecipient_.subject_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessageHeader.subject)
}

// .Recipients recipients = 2;
inline bool ApplicationMessageHeader::has_recipients() const {
  return SubjectOrRecipient_case() == kRecipients;
}
inline bool ApplicationMessageHeader::_internal_has_recipients() const {
  return SubjectOrRecipient_case() == kRecipients;
}
inline void ApplicationMessageHeader::set_has_recipients() {
  _impl_._oneof_case_[0] = kRecipients;
}
inline void ApplicationMessageHeader::clear_recipients() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (SubjectOrRecipient_case() == kRecipients) {
    if (GetArena() == nullptr) {
      delete _impl_.SubjectOrRecipient_.recipients_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.SubjectOrRecipient_.recipients_);
    }
    clear_has_SubjectOrRecipient();
  }
}
inline ::Recipients* ApplicationMessageHeader::release_recipients() {
  // @@protoc_insertion_point(field_release:ApplicationMessageHeader.recipients)
  if (SubjectOrRecipient_case() == kRecipients) {
    clear_has_SubjectOrRecipient();
    auto* temp = _impl_.SubjectOrRecipient_.recipients_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.SubjectOrRecipient_.recipients_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Recipients& ApplicationMessageHeader::_internal_recipients() const {
  return SubjectOrRecipient_case() == kRecipients ? *_impl_.SubjectOrRecipient_.recipients_ : reinterpret_cast<::Recipients&>(::_Recipients_default_instance_);
}
inline const ::Recipients& ApplicationMessageHeader::recipients() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.recipients)
  return _internal_recipients();
}
inline ::Recipients* ApplicationMessageHeader::unsafe_arena_release_recipients() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ApplicationMessageHeader.recipients)
  if (SubjectOrRecipient_case() == kRecipients) {
    clear_has_SubjectOrRecipient();
    auto* temp = _impl_.SubjectOrRecipient_.recipients_;
    _impl_.SubjectOrRecipient_.recipients_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ApplicationMessageHeader::unsafe_arena_set_allocated_recipients(::Recipients* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_SubjectOrRecipient();
  if (value) {
    set_has_recipients();
    _impl_.SubjectOrRecipient_.recipients_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ApplicationMessageHeader.recipients)
}
inline ::Recipients* ApplicationMessageHeader::_internal_mutable_recipients() {
  if (SubjectOrRecipient_case() != kRecipients) {
    clear_SubjectOrRecipient();
    set_has_recipients();
    _impl_.SubjectOrRecipient_.recipients_ =
        ::google::protobuf::Message::DefaultConstruct<::Recipients>(GetArena());
  }
  return _impl_.SubjectOrRecipient_.recipients_;
}
inline ::Recipients* ApplicationMessageHeader::mutable_recipients() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Recipients* _msg = _internal_mutable_recipients();
  // @@protoc_insertion_point(field_mutable:ApplicationMessageHeader.recipients)
  return _msg;
}

// int64 expires = 3;
inline void ApplicationMessageHeader::clear_expires() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_ = ::int64_t{0};
}
inline ::int64_t ApplicationMessageHeader::expires() const {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.expires)
  return _internal_expires();
}
inline void ApplicationMessageHeader::set_expires(::int64_t value) {
  _internal_set_expires(value);
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.expires)
}
inline ::int64_t ApplicationMessageHeader::_internal_expires() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expires_;
}
inline void ApplicationMessageHeader::_internal_set_expires(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_ = value;
}

// string sender = 4;
inline void ApplicationMessageHeader::clear_sender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& ApplicationMessageHeader::sender() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ApplicationMessageHeader::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.sender)
}
inline std::string* ApplicationMessageHeader::mutable_sender() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:ApplicationMessageHeader.sender)
  return _s;
}
inline const std::string& ApplicationMessageHeader::_internal_sender() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sender_.Get();
}
inline void ApplicationMessageHeader::_internal_set_sender(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_.Set(value, GetArena());
}
inline std::string* ApplicationMessageHeader::_internal_mutable_sender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sender_.Mutable( GetArena());
}
inline std::string* ApplicationMessageHeader::release_sender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApplicationMessageHeader.sender)
  return _impl_.sender_.Release();
}
inline void ApplicationMessageHeader::set_allocated_sender(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sender_.IsDefault()) {
    _impl_.sender_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessageHeader.sender)
}

// optional string qosProfile = 5;
inline bool ApplicationMessageHeader::has_qosprofile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ApplicationMessageHeader::clear_qosprofile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qosprofile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApplicationMessageHeader::qosprofile() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.qosProfile)
  return _internal_qosprofile();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ApplicationMessageHeader::set_qosprofile(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.qosprofile_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.qosProfile)
}
inline std::string* ApplicationMessageHeader::mutable_qosprofile() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_qosprofile();
  // @@protoc_insertion_point(field_mutable:ApplicationMessageHeader.qosProfile)
  return _s;
}
inline const std::string& ApplicationMessageHeader::_internal_qosprofile() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.qosprofile_.Get();
}
inline void ApplicationMessageHeader::_internal_set_qosprofile(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.qosprofile_.Set(value, GetArena());
}
inline std::string* ApplicationMessageHeader::_internal_mutable_qosprofile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.qosprofile_.Mutable( GetArena());
}
inline std::string* ApplicationMessageHeader::release_qosprofile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ApplicationMessageHeader.qosProfile)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.qosprofile_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.qosprofile_.Set("", GetArena());
  }
  return released;
}
inline void ApplicationMessageHeader::set_allocated_qosprofile(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.qosprofile_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.qosprofile_.IsDefault()) {
    _impl_.qosprofile_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ApplicationMessageHeader.qosProfile)
}

// uint32 bodySizeNumBytes = 6;
inline void ApplicationMessageHeader::clear_bodysizenumbytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bodysizenumbytes_ = 0u;
}
inline ::uint32_t ApplicationMessageHeader::bodysizenumbytes() const {
  // @@protoc_insertion_point(field_get:ApplicationMessageHeader.bodySizeNumBytes)
  return _internal_bodysizenumbytes();
}
inline void ApplicationMessageHeader::set_bodysizenumbytes(::uint32_t value) {
  _internal_set_bodysizenumbytes(value);
  // @@protoc_insertion_point(field_set:ApplicationMessageHeader.bodySizeNumBytes)
}
inline ::uint32_t ApplicationMessageHeader::_internal_bodysizenumbytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bodysizenumbytes_;
}
inline void ApplicationMessageHeader::_internal_set_bodysizenumbytes(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bodysizenumbytes_ = value;
}

inline bool ApplicationMessageHeader::has_SubjectOrRecipient() const {
  return SubjectOrRecipient_case() != SUBJECTORRECIPIENT_NOT_SET;
}
inline void ApplicationMessageHeader::clear_has_SubjectOrRecipient() {
  _impl_._oneof_case_[0] = SUBJECTORRECIPIENT_NOT_SET;
}
inline ApplicationMessageHeader::SubjectOrRecipientCase ApplicationMessageHeader::SubjectOrRecipient_case() const {
  return ApplicationMessageHeader::SubjectOrRecipientCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Recipients

// repeated string recipients = 1;
inline int Recipients::_internal_recipients_size() const {
  return _internal_recipients().size();
}
inline int Recipients::recipients_size() const {
  return _internal_recipients_size();
}
inline void Recipients::clear_recipients() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recipients_.Clear();
}
inline std::string* Recipients::add_recipients() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_recipients()->Add();
  // @@protoc_insertion_point(field_add_mutable:Recipients.recipients)
  return _s;
}
inline const std::string& Recipients::recipients(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Recipients.recipients)
  return _internal_recipients().Get(index);
}
inline std::string* Recipients::mutable_recipients(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Recipients.recipients)
  return _internal_mutable_recipients()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Recipients::set_recipients(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_recipients()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:Recipients.recipients)
}
template <typename Arg_, typename... Args_>
inline void Recipients::add_recipients(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_recipients(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:Recipients.recipients)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Recipients::recipients() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Recipients.recipients)
  return _internal_recipients();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Recipients::mutable_recipients() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Recipients.recipients)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_recipients();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Recipients::_internal_recipients() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recipients_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Recipients::_internal_mutable_recipients() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.recipients_;
}

// -------------------------------------------------------------------

// MmtpMessage

// .MsgType msgType = 1;
inline void MmtpMessage::clear_msgtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msgtype_ = 0;
}
inline ::MsgType MmtpMessage::msgtype() const {
  // @@protoc_insertion_point(field_get:MmtpMessage.msgType)
  return _internal_msgtype();
}
inline void MmtpMessage::set_msgtype(::MsgType value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:MmtpMessage.msgType)
}
inline ::MsgType MmtpMessage::_internal_msgtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::MsgType>(_impl_.msgtype_);
}
inline void MmtpMessage::_internal_set_msgtype(::MsgType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msgtype_ = value;
}

// string uuid = 2;
inline void MmtpMessage::clear_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& MmtpMessage::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MmtpMessage.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MmtpMessage::set_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MmtpMessage.uuid)
}
inline std::string* MmtpMessage::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:MmtpMessage.uuid)
  return _s;
}
inline const std::string& MmtpMessage::_internal_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uuid_.Get();
}
inline void MmtpMessage::_internal_set_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.Set(value, GetArena());
}
inline std::string* MmtpMessage::_internal_mutable_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uuid_.Mutable( GetArena());
}
inline std::string* MmtpMessage::release_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MmtpMessage.uuid)
  return _impl_.uuid_.Release();
}
inline void MmtpMessage::set_allocated_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MmtpMessage.uuid)
}

// .ProtocolMessage protocolMessage = 3;
inline bool MmtpMessage::has_protocolmessage() const {
  return body_case() == kProtocolMessage;
}
inline bool MmtpMessage::_internal_has_protocolmessage() const {
  return body_case() == kProtocolMessage;
}
inline void MmtpMessage::set_has_protocolmessage() {
  _impl_._oneof_case_[0] = kProtocolMessage;
}
inline void MmtpMessage::clear_protocolmessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kProtocolMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.protocolmessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.protocolmessage_);
    }
    clear_has_body();
  }
}
inline ::ProtocolMessage* MmtpMessage::release_protocolmessage() {
  // @@protoc_insertion_point(field_release:MmtpMessage.protocolMessage)
  if (body_case() == kProtocolMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.protocolmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.protocolmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ProtocolMessage& MmtpMessage::_internal_protocolmessage() const {
  return body_case() == kProtocolMessage ? *_impl_.body_.protocolmessage_ : reinterpret_cast<::ProtocolMessage&>(::_ProtocolMessage_default_instance_);
}
inline const ::ProtocolMessage& MmtpMessage::protocolmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MmtpMessage.protocolMessage)
  return _internal_protocolmessage();
}
inline ::ProtocolMessage* MmtpMessage::unsafe_arena_release_protocolmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MmtpMessage.protocolMessage)
  if (body_case() == kProtocolMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.protocolmessage_;
    _impl_.body_.protocolmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MmtpMessage::unsafe_arena_set_allocated_protocolmessage(::ProtocolMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_protocolmessage();
    _impl_.body_.protocolmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MmtpMessage.protocolMessage)
}
inline ::ProtocolMessage* MmtpMessage::_internal_mutable_protocolmessage() {
  if (body_case() != kProtocolMessage) {
    clear_body();
    set_has_protocolmessage();
    _impl_.body_.protocolmessage_ =
        ::google::protobuf::Message::DefaultConstruct<::ProtocolMessage>(GetArena());
  }
  return _impl_.body_.protocolmessage_;
}
inline ::ProtocolMessage* MmtpMessage::mutable_protocolmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ProtocolMessage* _msg = _internal_mutable_protocolmessage();
  // @@protoc_insertion_point(field_mutable:MmtpMessage.protocolMessage)
  return _msg;
}

// .ResponseMessage responseMessage = 4;
inline bool MmtpMessage::has_responsemessage() const {
  return body_case() == kResponseMessage;
}
inline bool MmtpMessage::_internal_has_responsemessage() const {
  return body_case() == kResponseMessage;
}
inline void MmtpMessage::set_has_responsemessage() {
  _impl_._oneof_case_[0] = kResponseMessage;
}
inline void MmtpMessage::clear_responsemessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kResponseMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.responsemessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.responsemessage_);
    }
    clear_has_body();
  }
}
inline ::ResponseMessage* MmtpMessage::release_responsemessage() {
  // @@protoc_insertion_point(field_release:MmtpMessage.responseMessage)
  if (body_case() == kResponseMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.responsemessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.responsemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ResponseMessage& MmtpMessage::_internal_responsemessage() const {
  return body_case() == kResponseMessage ? *_impl_.body_.responsemessage_ : reinterpret_cast<::ResponseMessage&>(::_ResponseMessage_default_instance_);
}
inline const ::ResponseMessage& MmtpMessage::responsemessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MmtpMessage.responseMessage)
  return _internal_responsemessage();
}
inline ::ResponseMessage* MmtpMessage::unsafe_arena_release_responsemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MmtpMessage.responseMessage)
  if (body_case() == kResponseMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.responsemessage_;
    _impl_.body_.responsemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MmtpMessage::unsafe_arena_set_allocated_responsemessage(::ResponseMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_responsemessage();
    _impl_.body_.responsemessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MmtpMessage.responseMessage)
}
inline ::ResponseMessage* MmtpMessage::_internal_mutable_responsemessage() {
  if (body_case() != kResponseMessage) {
    clear_body();
    set_has_responsemessage();
    _impl_.body_.responsemessage_ =
        ::google::protobuf::Message::DefaultConstruct<::ResponseMessage>(GetArena());
  }
  return _impl_.body_.responsemessage_;
}
inline ::ResponseMessage* MmtpMessage::mutable_responsemessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ResponseMessage* _msg = _internal_mutable_responsemessage();
  // @@protoc_insertion_point(field_mutable:MmtpMessage.responseMessage)
  return _msg;
}

inline bool MmtpMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void MmtpMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline MmtpMessage::BodyCase MmtpMessage::body_case() const {
  return MmtpMessage::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProtocolMessage

// .ProtocolMessageType protocolMsgType = 1;
inline void ProtocolMessage::clear_protocolmsgtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocolmsgtype_ = 0;
}
inline ::ProtocolMessageType ProtocolMessage::protocolmsgtype() const {
  // @@protoc_insertion_point(field_get:ProtocolMessage.protocolMsgType)
  return _internal_protocolmsgtype();
}
inline void ProtocolMessage::set_protocolmsgtype(::ProtocolMessageType value) {
  _internal_set_protocolmsgtype(value);
  // @@protoc_insertion_point(field_set:ProtocolMessage.protocolMsgType)
}
inline ::ProtocolMessageType ProtocolMessage::_internal_protocolmsgtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ProtocolMessageType>(_impl_.protocolmsgtype_);
}
inline void ProtocolMessage::_internal_set_protocolmsgtype(::ProtocolMessageType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocolmsgtype_ = value;
}

// .Subscribe subscribeMessage = 2;
inline bool ProtocolMessage::has_subscribemessage() const {
  return body_case() == kSubscribeMessage;
}
inline bool ProtocolMessage::_internal_has_subscribemessage() const {
  return body_case() == kSubscribeMessage;
}
inline void ProtocolMessage::set_has_subscribemessage() {
  _impl_._oneof_case_[0] = kSubscribeMessage;
}
inline void ProtocolMessage::clear_subscribemessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kSubscribeMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.subscribemessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.subscribemessage_);
    }
    clear_has_body();
  }
}
inline ::Subscribe* ProtocolMessage::release_subscribemessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.subscribeMessage)
  if (body_case() == kSubscribeMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.subscribemessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.subscribemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Subscribe& ProtocolMessage::_internal_subscribemessage() const {
  return body_case() == kSubscribeMessage ? *_impl_.body_.subscribemessage_ : reinterpret_cast<::Subscribe&>(::_Subscribe_default_instance_);
}
inline const ::Subscribe& ProtocolMessage::subscribemessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtocolMessage.subscribeMessage)
  return _internal_subscribemessage();
}
inline ::Subscribe* ProtocolMessage::unsafe_arena_release_subscribemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.subscribeMessage)
  if (body_case() == kSubscribeMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.subscribemessage_;
    _impl_.body_.subscribemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_subscribemessage(::Subscribe* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_subscribemessage();
    _impl_.body_.subscribemessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.subscribeMessage)
}
inline ::Subscribe* ProtocolMessage::_internal_mutable_subscribemessage() {
  if (body_case() != kSubscribeMessage) {
    clear_body();
    set_has_subscribemessage();
    _impl_.body_.subscribemessage_ =
        ::google::protobuf::Message::DefaultConstruct<::Subscribe>(GetArena());
  }
  return _impl_.body_.subscribemessage_;
}
inline ::Subscribe* ProtocolMessage::mutable_subscribemessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Subscribe* _msg = _internal_mutable_subscribemessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.subscribeMessage)
  return _msg;
}

// .Unsubscribe unsubscribeMessage = 3;
inline bool ProtocolMessage::has_unsubscribemessage() const {
  return body_case() == kUnsubscribeMessage;
}
inline bool ProtocolMessage::_internal_has_unsubscribemessage() const {
  return body_case() == kUnsubscribeMessage;
}
inline void ProtocolMessage::set_has_unsubscribemessage() {
  _impl_._oneof_case_[0] = kUnsubscribeMessage;
}
inline void ProtocolMessage::clear_unsubscribemessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kUnsubscribeMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.unsubscribemessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.unsubscribemessage_);
    }
    clear_has_body();
  }
}
inline ::Unsubscribe* ProtocolMessage::release_unsubscribemessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.unsubscribeMessage)
  if (body_case() == kUnsubscribeMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.unsubscribemessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.unsubscribemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Unsubscribe& ProtocolMessage::_internal_unsubscribemessage() const {
  return body_case() == kUnsubscribeMessage ? *_impl_.body_.unsubscribemessage_ : reinterpret_cast<::Unsubscribe&>(::_Unsubscribe_default_instance_);
}
inline const ::Unsubscribe& ProtocolMessage::unsubscribemessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtocolMessage.unsubscribeMessage)
  return _internal_unsubscribemessage();
}
inline ::Unsubscribe* ProtocolMessage::unsafe_arena_release_unsubscribemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.unsubscribeMessage)
  if (body_case() == kUnsubscribeMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.unsubscribemessage_;
    _impl_.body_.unsubscribemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_unsubscribemessage(::Unsubscribe* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_unsubscribemessage();
    _impl_.body_.unsubscribemessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.unsubscribeMessage)
}
inline ::Unsubscribe* ProtocolMessage::_internal_mutable_unsubscribemessage() {
  if (body_case() != kUnsubscribeMessage) {
    clear_body();
    set_has_unsubscribemessage();
    _impl_.body_.unsubscribemessage_ =
        ::google::protobuf::Message::DefaultConstruct<::Unsubscribe>(GetArena());
  }
  return _impl_.body_.unsubscribemessage_;
}
inline ::Unsubscribe* ProtocolMessage::mutable_unsubscribemessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Unsubscribe* _msg = _internal_mutable_unsubscribemessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.unsubscribeMessage)
  return _msg;
}

// .Send sendMessage = 4;
inline bool ProtocolMessage::has_sendmessage() const {
  return body_case() == kSendMessage;
}
inline bool ProtocolMessage::_internal_has_sendmessage() const {
  return body_case() == kSendMessage;
}
inline void ProtocolMessage::set_has_sendmessage() {
  _impl_._oneof_case_[0] = kSendMessage;
}
inline void ProtocolMessage::clear_sendmessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kSendMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.sendmessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.sendmessage_);
    }
    clear_has_body();
  }
}
inline ::Send* ProtocolMessage::release_sendmessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.sendMessage)
  if (body_case() == kSendMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.sendmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.sendmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Send& ProtocolMessage::_internal_sendmessage() const {
  return body_case() == kSendMessage ? *_impl_.body_.sendmessage_ : reinterpret_cast<::Send&>(::_Send_default_instance_);
}
inline const ::Send& ProtocolMessage::sendmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtocolMessage.sendMessage)
  return _internal_sendmessage();
}
inline ::Send* ProtocolMessage::unsafe_arena_release_sendmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.sendMessage)
  if (body_case() == kSendMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.sendmessage_;
    _impl_.body_.sendmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_sendmessage(::Send* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_sendmessage();
    _impl_.body_.sendmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.sendMessage)
}
inline ::Send* ProtocolMessage::_internal_mutable_sendmessage() {
  if (body_case() != kSendMessage) {
    clear_body();
    set_has_sendmessage();
    _impl_.body_.sendmessage_ =
        ::google::protobuf::Message::DefaultConstruct<::Send>(GetArena());
  }
  return _impl_.body_.sendmessage_;
}
inline ::Send* ProtocolMessage::mutable_sendmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Send* _msg = _internal_mutable_sendmessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.sendMessage)
  return _msg;
}

// .Receive receiveMessage = 5;
inline bool ProtocolMessage::has_receivemessage() const {
  return body_case() == kReceiveMessage;
}
inline bool ProtocolMessage::_internal_has_receivemessage() const {
  return body_case() == kReceiveMessage;
}
inline void ProtocolMessage::set_has_receivemessage() {
  _impl_._oneof_case_[0] = kReceiveMessage;
}
inline void ProtocolMessage::clear_receivemessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kReceiveMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.receivemessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.receivemessage_);
    }
    clear_has_body();
  }
}
inline ::Receive* ProtocolMessage::release_receivemessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.receiveMessage)
  if (body_case() == kReceiveMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.receivemessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.receivemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Receive& ProtocolMessage::_internal_receivemessage() const {
  return body_case() == kReceiveMessage ? *_impl_.body_.receivemessage_ : reinterpret_cast<::Receive&>(::_Receive_default_instance_);
}
inline const ::Receive& ProtocolMessage::receivemessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtocolMessage.receiveMessage)
  return _internal_receivemessage();
}
inline ::Receive* ProtocolMessage::unsafe_arena_release_receivemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.receiveMessage)
  if (body_case() == kReceiveMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.receivemessage_;
    _impl_.body_.receivemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_receivemessage(::Receive* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_receivemessage();
    _impl_.body_.receivemessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.receiveMessage)
}
inline ::Receive* ProtocolMessage::_internal_mutable_receivemessage() {
  if (body_case() != kReceiveMessage) {
    clear_body();
    set_has_receivemessage();
    _impl_.body_.receivemessage_ =
        ::google::protobuf::Message::DefaultConstruct<::Receive>(GetArena());
  }
  return _impl_.body_.receivemessage_;
}
inline ::Receive* ProtocolMessage::mutable_receivemessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Receive* _msg = _internal_mutable_receivemessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.receiveMessage)
  return _msg;
}

// .Fetch fetchMessage = 6;
inline bool ProtocolMessage::has_fetchmessage() const {
  return body_case() == kFetchMessage;
}
inline bool ProtocolMessage::_internal_has_fetchmessage() const {
  return body_case() == kFetchMessage;
}
inline void ProtocolMessage::set_has_fetchmessage() {
  _impl_._oneof_case_[0] = kFetchMessage;
}
inline void ProtocolMessage::clear_fetchmessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kFetchMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.fetchmessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.fetchmessage_);
    }
    clear_has_body();
  }
}
inline ::Fetch* ProtocolMessage::release_fetchmessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.fetchMessage)
  if (body_case() == kFetchMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.fetchmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.fetchmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Fetch& ProtocolMessage::_internal_fetchmessage() const {
  return body_case() == kFetchMessage ? *_impl_.body_.fetchmessage_ : reinterpret_cast<::Fetch&>(::_Fetch_default_instance_);
}
inline const ::Fetch& ProtocolMessage::fetchmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtocolMessage.fetchMessage)
  return _internal_fetchmessage();
}
inline ::Fetch* ProtocolMessage::unsafe_arena_release_fetchmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.fetchMessage)
  if (body_case() == kFetchMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.fetchmessage_;
    _impl_.body_.fetchmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_fetchmessage(::Fetch* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_fetchmessage();
    _impl_.body_.fetchmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.fetchMessage)
}
inline ::Fetch* ProtocolMessage::_internal_mutable_fetchmessage() {
  if (body_case() != kFetchMessage) {
    clear_body();
    set_has_fetchmessage();
    _impl_.body_.fetchmessage_ =
        ::google::protobuf::Message::DefaultConstruct<::Fetch>(GetArena());
  }
  return _impl_.body_.fetchmessage_;
}
inline ::Fetch* ProtocolMessage::mutable_fetchmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Fetch* _msg = _internal_mutable_fetchmessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.fetchMessage)
  return _msg;
}

// .Disconnect disconnectMessage = 7;
inline bool ProtocolMessage::has_disconnectmessage() const {
  return body_case() == kDisconnectMessage;
}
inline bool ProtocolMessage::_internal_has_disconnectmessage() const {
  return body_case() == kDisconnectMessage;
}
inline void ProtocolMessage::set_has_disconnectmessage() {
  _impl_._oneof_case_[0] = kDisconnectMessage;
}
inline void ProtocolMessage::clear_disconnectmessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kDisconnectMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.disconnectmessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.disconnectmessage_);
    }
    clear_has_body();
  }
}
inline ::Disconnect* ProtocolMessage::release_disconnectmessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.disconnectMessage)
  if (body_case() == kDisconnectMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.disconnectmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.disconnectmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Disconnect& ProtocolMessage::_internal_disconnectmessage() const {
  return body_case() == kDisconnectMessage ? *_impl_.body_.disconnectmessage_ : reinterpret_cast<::Disconnect&>(::_Disconnect_default_instance_);
}
inline const ::Disconnect& ProtocolMessage::disconnectmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtocolMessage.disconnectMessage)
  return _internal_disconnectmessage();
}
inline ::Disconnect* ProtocolMessage::unsafe_arena_release_disconnectmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.disconnectMessage)
  if (body_case() == kDisconnectMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.disconnectmessage_;
    _impl_.body_.disconnectmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_disconnectmessage(::Disconnect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_disconnectmessage();
    _impl_.body_.disconnectmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.disconnectMessage)
}
inline ::Disconnect* ProtocolMessage::_internal_mutable_disconnectmessage() {
  if (body_case() != kDisconnectMessage) {
    clear_body();
    set_has_disconnectmessage();
    _impl_.body_.disconnectmessage_ =
        ::google::protobuf::Message::DefaultConstruct<::Disconnect>(GetArena());
  }
  return _impl_.body_.disconnectmessage_;
}
inline ::Disconnect* ProtocolMessage::mutable_disconnectmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Disconnect* _msg = _internal_mutable_disconnectmessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.disconnectMessage)
  return _msg;
}

// .Connect connectMessage = 8;
inline bool ProtocolMessage::has_connectmessage() const {
  return body_case() == kConnectMessage;
}
inline bool ProtocolMessage::_internal_has_connectmessage() const {
  return body_case() == kConnectMessage;
}
inline void ProtocolMessage::set_has_connectmessage() {
  _impl_._oneof_case_[0] = kConnectMessage;
}
inline void ProtocolMessage::clear_connectmessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kConnectMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.connectmessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.connectmessage_);
    }
    clear_has_body();
  }
}
inline ::Connect* ProtocolMessage::release_connectmessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.connectMessage)
  if (body_case() == kConnectMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.connectmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.connectmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Connect& ProtocolMessage::_internal_connectmessage() const {
  return body_case() == kConnectMessage ? *_impl_.body_.connectmessage_ : reinterpret_cast<::Connect&>(::_Connect_default_instance_);
}
inline const ::Connect& ProtocolMessage::connectmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtocolMessage.connectMessage)
  return _internal_connectmessage();
}
inline ::Connect* ProtocolMessage::unsafe_arena_release_connectmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.connectMessage)
  if (body_case() == kConnectMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.connectmessage_;
    _impl_.body_.connectmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_connectmessage(::Connect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_connectmessage();
    _impl_.body_.connectmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.connectMessage)
}
inline ::Connect* ProtocolMessage::_internal_mutable_connectmessage() {
  if (body_case() != kConnectMessage) {
    clear_body();
    set_has_connectmessage();
    _impl_.body_.connectmessage_ =
        ::google::protobuf::Message::DefaultConstruct<::Connect>(GetArena());
  }
  return _impl_.body_.connectmessage_;
}
inline ::Connect* ProtocolMessage::mutable_connectmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Connect* _msg = _internal_mutable_connectmessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.connectMessage)
  return _msg;
}

// .Notify notifyMessage = 9;
inline bool ProtocolMessage::has_notifymessage() const {
  return body_case() == kNotifyMessage;
}
inline bool ProtocolMessage::_internal_has_notifymessage() const {
  return body_case() == kNotifyMessage;
}
inline void ProtocolMessage::set_has_notifymessage() {
  _impl_._oneof_case_[0] = kNotifyMessage;
}
inline void ProtocolMessage::clear_notifymessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kNotifyMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.notifymessage_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.notifymessage_);
    }
    clear_has_body();
  }
}
inline ::Notify* ProtocolMessage::release_notifymessage() {
  // @@protoc_insertion_point(field_release:ProtocolMessage.notifyMessage)
  if (body_case() == kNotifyMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.notifymessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.notifymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Notify& ProtocolMessage::_internal_notifymessage() const {
  return body_case() == kNotifyMessage ? *_impl_.body_.notifymessage_ : reinterpret_cast<::Notify&>(::_Notify_default_instance_);
}
inline const ::Notify& ProtocolMessage::notifymessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ProtocolMessage.notifyMessage)
  return _internal_notifymessage();
}
inline ::Notify* ProtocolMessage::unsafe_arena_release_notifymessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ProtocolMessage.notifyMessage)
  if (body_case() == kNotifyMessage) {
    clear_has_body();
    auto* temp = _impl_.body_.notifymessage_;
    _impl_.body_.notifymessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProtocolMessage::unsafe_arena_set_allocated_notifymessage(::Notify* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_notifymessage();
    _impl_.body_.notifymessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtocolMessage.notifyMessage)
}
inline ::Notify* ProtocolMessage::_internal_mutable_notifymessage() {
  if (body_case() != kNotifyMessage) {
    clear_body();
    set_has_notifymessage();
    _impl_.body_.notifymessage_ =
        ::google::protobuf::Message::DefaultConstruct<::Notify>(GetArena());
  }
  return _impl_.body_.notifymessage_;
}
inline ::Notify* ProtocolMessage::mutable_notifymessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Notify* _msg = _internal_mutable_notifymessage();
  // @@protoc_insertion_point(field_mutable:ProtocolMessage.notifyMessage)
  return _msg;
}

inline bool ProtocolMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void ProtocolMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline ProtocolMessage::BodyCase ProtocolMessage::body_case() const {
  return ProtocolMessage::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Subscribe

// string subject = 1;
inline bool Subscribe::has_subject() const {
  return subjectOrDirectMessages_case() == kSubject;
}
inline void Subscribe::set_has_subject() {
  _impl_._oneof_case_[0] = kSubject;
}
inline void Subscribe::clear_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() == kSubject) {
    _impl_.subjectOrDirectMessages_.subject_.Destroy();
    clear_has_subjectOrDirectMessages();
  }
}
inline const std::string& Subscribe::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Subscribe.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Subscribe::set_subject(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() != kSubject) {
    clear_subjectOrDirectMessages();

    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  _impl_.subjectOrDirectMessages_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Subscribe.subject)
}
inline std::string* Subscribe::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:Subscribe.subject)
  return _s;
}
inline const std::string& Subscribe::_internal_subject() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (subjectOrDirectMessages_case() != kSubject) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.subjectOrDirectMessages_.subject_.Get();
}
inline void Subscribe::_internal_set_subject(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() != kSubject) {
    clear_subjectOrDirectMessages();

    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  _impl_.subjectOrDirectMessages_.subject_.Set(value, GetArena());
}
inline std::string* Subscribe::_internal_mutable_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() != kSubject) {
    clear_subjectOrDirectMessages();

    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  return _impl_.subjectOrDirectMessages_.subject_.Mutable( GetArena());
}
inline std::string* Subscribe::release_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Subscribe.subject)
  if (subjectOrDirectMessages_case() != kSubject) {
    return nullptr;
  }
  clear_has_subjectOrDirectMessages();
  return _impl_.subjectOrDirectMessages_.subject_.Release();
}
inline void Subscribe::set_allocated_subject(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_subjectOrDirectMessages()) {
    clear_subjectOrDirectMessages();
  }
  if (value != nullptr) {
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:Subscribe.subject)
}

// bool directMessages = 2;
inline bool Subscribe::has_directmessages() const {
  return subjectOrDirectMessages_case() == kDirectMessages;
}
inline void Subscribe::set_has_directmessages() {
  _impl_._oneof_case_[0] = kDirectMessages;
}
inline void Subscribe::clear_directmessages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() == kDirectMessages) {
    _impl_.subjectOrDirectMessages_.directmessages_ = false;
    clear_has_subjectOrDirectMessages();
  }
}
inline bool Subscribe::directmessages() const {
  // @@protoc_insertion_point(field_get:Subscribe.directMessages)
  return _internal_directmessages();
}
inline void Subscribe::set_directmessages(bool value) {
  if (subjectOrDirectMessages_case() != kDirectMessages) {
    clear_subjectOrDirectMessages();
    set_has_directmessages();
  }
  _impl_.subjectOrDirectMessages_.directmessages_ = value;
  // @@protoc_insertion_point(field_set:Subscribe.directMessages)
}
inline bool Subscribe::_internal_directmessages() const {
  if (subjectOrDirectMessages_case() == kDirectMessages) {
    return _impl_.subjectOrDirectMessages_.directmessages_;
  }
  return false;
}

inline bool Subscribe::has_subjectOrDirectMessages() const {
  return subjectOrDirectMessages_case() != SUBJECTORDIRECTMESSAGES_NOT_SET;
}
inline void Subscribe::clear_has_subjectOrDirectMessages() {
  _impl_._oneof_case_[0] = SUBJECTORDIRECTMESSAGES_NOT_SET;
}
inline Subscribe::SubjectOrDirectMessagesCase Subscribe::subjectOrDirectMessages_case() const {
  return Subscribe::SubjectOrDirectMessagesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Unsubscribe

// string subject = 1;
inline bool Unsubscribe::has_subject() const {
  return subjectOrDirectMessages_case() == kSubject;
}
inline void Unsubscribe::set_has_subject() {
  _impl_._oneof_case_[0] = kSubject;
}
inline void Unsubscribe::clear_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() == kSubject) {
    _impl_.subjectOrDirectMessages_.subject_.Destroy();
    clear_has_subjectOrDirectMessages();
  }
}
inline const std::string& Unsubscribe::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Unsubscribe.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Unsubscribe::set_subject(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() != kSubject) {
    clear_subjectOrDirectMessages();

    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  _impl_.subjectOrDirectMessages_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Unsubscribe.subject)
}
inline std::string* Unsubscribe::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:Unsubscribe.subject)
  return _s;
}
inline const std::string& Unsubscribe::_internal_subject() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (subjectOrDirectMessages_case() != kSubject) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.subjectOrDirectMessages_.subject_.Get();
}
inline void Unsubscribe::_internal_set_subject(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() != kSubject) {
    clear_subjectOrDirectMessages();

    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  _impl_.subjectOrDirectMessages_.subject_.Set(value, GetArena());
}
inline std::string* Unsubscribe::_internal_mutable_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() != kSubject) {
    clear_subjectOrDirectMessages();

    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitDefault();
  }
  return _impl_.subjectOrDirectMessages_.subject_.Mutable( GetArena());
}
inline std::string* Unsubscribe::release_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Unsubscribe.subject)
  if (subjectOrDirectMessages_case() != kSubject) {
    return nullptr;
  }
  clear_has_subjectOrDirectMessages();
  return _impl_.subjectOrDirectMessages_.subject_.Release();
}
inline void Unsubscribe::set_allocated_subject(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_subjectOrDirectMessages()) {
    clear_subjectOrDirectMessages();
  }
  if (value != nullptr) {
    set_has_subject();
    _impl_.subjectOrDirectMessages_.subject_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:Unsubscribe.subject)
}

// bool directMessages = 2;
inline bool Unsubscribe::has_directmessages() const {
  return subjectOrDirectMessages_case() == kDirectMessages;
}
inline void Unsubscribe::set_has_directmessages() {
  _impl_._oneof_case_[0] = kDirectMessages;
}
inline void Unsubscribe::clear_directmessages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subjectOrDirectMessages_case() == kDirectMessages) {
    _impl_.subjectOrDirectMessages_.directmessages_ = false;
    clear_has_subjectOrDirectMessages();
  }
}
inline bool Unsubscribe::directmessages() const {
  // @@protoc_insertion_point(field_get:Unsubscribe.directMessages)
  return _internal_directmessages();
}
inline void Unsubscribe::set_directmessages(bool value) {
  if (subjectOrDirectMessages_case() != kDirectMessages) {
    clear_subjectOrDirectMessages();
    set_has_directmessages();
  }
  _impl_.subjectOrDirectMessages_.directmessages_ = value;
  // @@protoc_insertion_point(field_set:Unsubscribe.directMessages)
}
inline bool Unsubscribe::_internal_directmessages() const {
  if (subjectOrDirectMessages_case() == kDirectMessages) {
    return _impl_.subjectOrDirectMessages_.directmessages_;
  }
  return false;
}

inline bool Unsubscribe::has_subjectOrDirectMessages() const {
  return subjectOrDirectMessages_case() != SUBJECTORDIRECTMESSAGES_NOT_SET;
}
inline void Unsubscribe::clear_has_subjectOrDirectMessages() {
  _impl_._oneof_case_[0] = SUBJECTORDIRECTMESSAGES_NOT_SET;
}
inline Unsubscribe::SubjectOrDirectMessagesCase Unsubscribe::subjectOrDirectMessages_case() const {
  return Unsubscribe::SubjectOrDirectMessagesCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Send

// .ApplicationMessage applicationMessage = 1;
inline bool Send::has_applicationmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.applicationmessage_ != nullptr);
  return value;
}
inline void Send::clear_applicationmessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.applicationmessage_ != nullptr) _impl_.applicationmessage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ApplicationMessage& Send::_internal_applicationmessage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ApplicationMessage* p = _impl_.applicationmessage_;
  return p != nullptr ? *p : reinterpret_cast<const ::ApplicationMessage&>(::_ApplicationMessage_default_instance_);
}
inline const ::ApplicationMessage& Send::applicationmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Send.applicationMessage)
  return _internal_applicationmessage();
}
inline void Send::unsafe_arena_set_allocated_applicationmessage(::ApplicationMessage* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.applicationmessage_);
  }
  _impl_.applicationmessage_ = reinterpret_cast<::ApplicationMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Send.applicationMessage)
}
inline ::ApplicationMessage* Send::release_applicationmessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ApplicationMessage* released = _impl_.applicationmessage_;
  _impl_.applicationmessage_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ApplicationMessage* Send::unsafe_arena_release_applicationmessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Send.applicationMessage)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ApplicationMessage* temp = _impl_.applicationmessage_;
  _impl_.applicationmessage_ = nullptr;
  return temp;
}
inline ::ApplicationMessage* Send::_internal_mutable_applicationmessage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.applicationmessage_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ApplicationMessage>(GetArena());
    _impl_.applicationmessage_ = reinterpret_cast<::ApplicationMessage*>(p);
  }
  return _impl_.applicationmessage_;
}
inline ::ApplicationMessage* Send::mutable_applicationmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ApplicationMessage* _msg = _internal_mutable_applicationmessage();
  // @@protoc_insertion_point(field_mutable:Send.applicationMessage)
  return _msg;
}
inline void Send::set_allocated_applicationmessage(::ApplicationMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.applicationmessage_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.applicationmessage_ = reinterpret_cast<::ApplicationMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:Send.applicationMessage)
}

// -------------------------------------------------------------------

// Receive

// optional .Filter filter = 1;
inline bool Receive::has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void Receive::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Filter& Receive::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::Filter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::Filter&>(::_Filter_default_instance_);
}
inline const ::Filter& Receive::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Receive.filter)
  return _internal_filter();
}
inline void Receive::unsafe_arena_set_allocated_filter(::Filter* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::Filter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Receive.filter)
}
inline ::Filter* Receive::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Filter* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::Filter* Receive::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Receive.filter)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Filter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::Filter* Receive::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Filter>(GetArena());
    _impl_.filter_ = reinterpret_cast<::Filter*>(p);
  }
  return _impl_.filter_;
}
inline ::Filter* Receive::mutable_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Filter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:Receive.filter)
  return _msg;
}
inline void Receive::set_allocated_filter(::Filter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.filter_ = reinterpret_cast<::Filter*>(value);
  // @@protoc_insertion_point(field_set_allocated:Receive.filter)
}

// -------------------------------------------------------------------

// Filter

// repeated string messageUuids = 1;
inline int Filter::_internal_messageuuids_size() const {
  return _internal_messageuuids().size();
}
inline int Filter::messageuuids_size() const {
  return _internal_messageuuids_size();
}
inline void Filter::clear_messageuuids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messageuuids_.Clear();
}
inline std::string* Filter::add_messageuuids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_messageuuids()->Add();
  // @@protoc_insertion_point(field_add_mutable:Filter.messageUuids)
  return _s;
}
inline const std::string& Filter::messageuuids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Filter.messageUuids)
  return _internal_messageuuids().Get(index);
}
inline std::string* Filter::mutable_messageuuids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Filter.messageUuids)
  return _internal_mutable_messageuuids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Filter::set_messageuuids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_messageuuids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:Filter.messageUuids)
}
template <typename Arg_, typename... Args_>
inline void Filter::add_messageuuids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_messageuuids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:Filter.messageUuids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Filter::messageuuids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Filter.messageUuids)
  return _internal_messageuuids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Filter::mutable_messageuuids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Filter.messageUuids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_messageuuids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Filter::_internal_messageuuids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.messageuuids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Filter::_internal_mutable_messageuuids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.messageuuids_;
}

// -------------------------------------------------------------------

// Fetch

// -------------------------------------------------------------------

// Disconnect

// -------------------------------------------------------------------

// Connect

// optional string ownMrn = 1;
inline bool Connect::has_ownmrn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Connect::clear_ownmrn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ownmrn_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Connect::ownmrn() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Connect.ownMrn)
  return _internal_ownmrn();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Connect::set_ownmrn(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ownmrn_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Connect.ownMrn)
}
inline std::string* Connect::mutable_ownmrn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ownmrn();
  // @@protoc_insertion_point(field_mutable:Connect.ownMrn)
  return _s;
}
inline const std::string& Connect::_internal_ownmrn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ownmrn_.Get();
}
inline void Connect::_internal_set_ownmrn(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ownmrn_.Set(value, GetArena());
}
inline std::string* Connect::_internal_mutable_ownmrn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ownmrn_.Mutable( GetArena());
}
inline std::string* Connect::release_ownmrn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Connect.ownMrn)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ownmrn_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ownmrn_.Set("", GetArena());
  }
  return released;
}
inline void Connect::set_allocated_ownmrn(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ownmrn_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ownmrn_.IsDefault()) {
    _impl_.ownmrn_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:Connect.ownMrn)
}

// optional string reconnectToken = 2;
inline bool Connect::has_reconnecttoken() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Connect::clear_reconnecttoken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reconnecttoken_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Connect::reconnecttoken() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Connect.reconnectToken)
  return _internal_reconnecttoken();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Connect::set_reconnecttoken(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reconnecttoken_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Connect.reconnectToken)
}
inline std::string* Connect::mutable_reconnecttoken() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reconnecttoken();
  // @@protoc_insertion_point(field_mutable:Connect.reconnectToken)
  return _s;
}
inline const std::string& Connect::_internal_reconnecttoken() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reconnecttoken_.Get();
}
inline void Connect::_internal_set_reconnecttoken(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reconnecttoken_.Set(value, GetArena());
}
inline std::string* Connect::_internal_mutable_reconnecttoken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.reconnecttoken_.Mutable( GetArena());
}
inline std::string* Connect::release_reconnecttoken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:Connect.reconnectToken)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.reconnecttoken_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reconnecttoken_.Set("", GetArena());
  }
  return released;
}
inline void Connect::set_allocated_reconnecttoken(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.reconnecttoken_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reconnecttoken_.IsDefault()) {
    _impl_.reconnecttoken_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:Connect.reconnectToken)
}

// -------------------------------------------------------------------

// Notify

// repeated .MessageMetadata messageMetadata = 1;
inline int Notify::_internal_messagemetadata_size() const {
  return _internal_messagemetadata().size();
}
inline int Notify::messagemetadata_size() const {
  return _internal_messagemetadata_size();
}
inline void Notify::clear_messagemetadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagemetadata_.Clear();
}
inline ::MessageMetadata* Notify::mutable_messagemetadata(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Notify.messageMetadata)
  return _internal_mutable_messagemetadata()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::MessageMetadata>* Notify::mutable_messagemetadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Notify.messageMetadata)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_messagemetadata();
}
inline const ::MessageMetadata& Notify::messagemetadata(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Notify.messageMetadata)
  return _internal_messagemetadata().Get(index);
}
inline ::MessageMetadata* Notify::add_messagemetadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::MessageMetadata* _add = _internal_mutable_messagemetadata()->Add();
  // @@protoc_insertion_point(field_add:Notify.messageMetadata)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::MessageMetadata>& Notify::messagemetadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Notify.messageMetadata)
  return _internal_messagemetadata();
}
inline const ::google::protobuf::RepeatedPtrField<::MessageMetadata>&
Notify::_internal_messagemetadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.messagemetadata_;
}
inline ::google::protobuf::RepeatedPtrField<::MessageMetadata>*
Notify::_internal_mutable_messagemetadata() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.messagemetadata_;
}

// -------------------------------------------------------------------

// ResponseMessage

// string responseToUuid = 1;
inline void ResponseMessage::clear_responsetouuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responsetouuid_.ClearToEmpty();
}
inline const std::string& ResponseMessage::responsetouuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseMessage.responseToUuid)
  return _internal_responsetouuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseMessage::set_responsetouuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responsetouuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ResponseMessage.responseToUuid)
}
inline std::string* ResponseMessage::mutable_responsetouuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_responsetouuid();
  // @@protoc_insertion_point(field_mutable:ResponseMessage.responseToUuid)
  return _s;
}
inline const std::string& ResponseMessage::_internal_responsetouuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.responsetouuid_.Get();
}
inline void ResponseMessage::_internal_set_responsetouuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responsetouuid_.Set(value, GetArena());
}
inline std::string* ResponseMessage::_internal_mutable_responsetouuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.responsetouuid_.Mutable( GetArena());
}
inline std::string* ResponseMessage::release_responsetouuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseMessage.responseToUuid)
  return _impl_.responsetouuid_.Release();
}
inline void ResponseMessage::set_allocated_responsetouuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.responsetouuid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.responsetouuid_.IsDefault()) {
    _impl_.responsetouuid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseMessage.responseToUuid)
}

// .ResponseEnum response = 2;
inline void ResponseMessage::clear_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_ = 0;
}
inline ::ResponseEnum ResponseMessage::response() const {
  // @@protoc_insertion_point(field_get:ResponseMessage.response)
  return _internal_response();
}
inline void ResponseMessage::set_response(::ResponseEnum value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:ResponseMessage.response)
}
inline ::ResponseEnum ResponseMessage::_internal_response() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ResponseEnum>(_impl_.response_);
}
inline void ResponseMessage::_internal_set_response(::ResponseEnum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.response_ = value;
}

// optional string reasonText = 3;
inline bool ResponseMessage::has_reasontext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ResponseMessage::clear_reasontext() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reasontext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseMessage::reasontext() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseMessage.reasonText)
  return _internal_reasontext();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseMessage::set_reasontext(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reasontext_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ResponseMessage.reasonText)
}
inline std::string* ResponseMessage::mutable_reasontext() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reasontext();
  // @@protoc_insertion_point(field_mutable:ResponseMessage.reasonText)
  return _s;
}
inline const std::string& ResponseMessage::_internal_reasontext() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reasontext_.Get();
}
inline void ResponseMessage::_internal_set_reasontext(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reasontext_.Set(value, GetArena());
}
inline std::string* ResponseMessage::_internal_mutable_reasontext() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reasontext_.Mutable( GetArena());
}
inline std::string* ResponseMessage::release_reasontext() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseMessage.reasonText)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.reasontext_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reasontext_.Set("", GetArena());
  }
  return released;
}
inline void ResponseMessage::set_allocated_reasontext(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reasontext_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reasontext_.IsDefault()) {
    _impl_.reasontext_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseMessage.reasonText)
}

// repeated .MessageMetadata messageMetadata = 4;
inline int ResponseMessage::_internal_messagemetadata_size() const {
  return _internal_messagemetadata().size();
}
inline int ResponseMessage::messagemetadata_size() const {
  return _internal_messagemetadata_size();
}
inline void ResponseMessage::clear_messagemetadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messagemetadata_.Clear();
}
inline ::MessageMetadata* ResponseMessage::mutable_messagemetadata(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ResponseMessage.messageMetadata)
  return _internal_mutable_messagemetadata()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::MessageMetadata>* ResponseMessage::mutable_messagemetadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ResponseMessage.messageMetadata)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_messagemetadata();
}
inline const ::MessageMetadata& ResponseMessage::messagemetadata(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseMessage.messageMetadata)
  return _internal_messagemetadata().Get(index);
}
inline ::MessageMetadata* ResponseMessage::add_messagemetadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::MessageMetadata* _add = _internal_mutable_messagemetadata()->Add();
  // @@protoc_insertion_point(field_add:ResponseMessage.messageMetadata)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::MessageMetadata>& ResponseMessage::messagemetadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ResponseMessage.messageMetadata)
  return _internal_messagemetadata();
}
inline const ::google::protobuf::RepeatedPtrField<::MessageMetadata>&
ResponseMessage::_internal_messagemetadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.messagemetadata_;
}
inline ::google::protobuf::RepeatedPtrField<::MessageMetadata>*
ResponseMessage::_internal_mutable_messagemetadata() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.messagemetadata_;
}

// repeated .ApplicationMessage applicationMessages = 5;
inline int ResponseMessage::_internal_applicationmessages_size() const {
  return _internal_applicationmessages().size();
}
inline int ResponseMessage::applicationmessages_size() const {
  return _internal_applicationmessages_size();
}
inline void ResponseMessage::clear_applicationmessages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.applicationmessages_.Clear();
}
inline ::ApplicationMessage* ResponseMessage::mutable_applicationmessages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ResponseMessage.applicationMessages)
  return _internal_mutable_applicationmessages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ApplicationMessage>* ResponseMessage::mutable_applicationmessages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ResponseMessage.applicationMessages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_applicationmessages();
}
inline const ::ApplicationMessage& ResponseMessage::applicationmessages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseMessage.applicationMessages)
  return _internal_applicationmessages().Get(index);
}
inline ::ApplicationMessage* ResponseMessage::add_applicationmessages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ApplicationMessage* _add = _internal_mutable_applicationmessages()->Add();
  // @@protoc_insertion_point(field_add:ResponseMessage.applicationMessages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ApplicationMessage>& ResponseMessage::applicationmessages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ResponseMessage.applicationMessages)
  return _internal_applicationmessages();
}
inline const ::google::protobuf::RepeatedPtrField<::ApplicationMessage>&
ResponseMessage::_internal_applicationmessages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.applicationmessages_;
}
inline ::google::protobuf::RepeatedPtrField<::ApplicationMessage>*
ResponseMessage::_internal_mutable_applicationmessages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.applicationmessages_;
}

// optional string reconnectToken = 6;
inline bool ResponseMessage::has_reconnecttoken() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ResponseMessage::clear_reconnecttoken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reconnecttoken_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseMessage::reconnecttoken() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseMessage.reconnectToken)
  return _internal_reconnecttoken();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResponseMessage::set_reconnecttoken(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reconnecttoken_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ResponseMessage.reconnectToken)
}
inline std::string* ResponseMessage::mutable_reconnecttoken() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reconnecttoken();
  // @@protoc_insertion_point(field_mutable:ResponseMessage.reconnectToken)
  return _s;
}
inline const std::string& ResponseMessage::_internal_reconnecttoken() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reconnecttoken_.Get();
}
inline void ResponseMessage::_internal_set_reconnecttoken(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reconnecttoken_.Set(value, GetArena());
}
inline std::string* ResponseMessage::_internal_mutable_reconnecttoken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.reconnecttoken_.Mutable( GetArena());
}
inline std::string* ResponseMessage::release_reconnecttoken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseMessage.reconnectToken)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.reconnecttoken_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.reconnecttoken_.Set("", GetArena());
  }
  return released;
}
inline void ResponseMessage::set_allocated_reconnecttoken(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.reconnecttoken_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reconnecttoken_.IsDefault()) {
    _impl_.reconnecttoken_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseMessage.reconnectToken)
}

// -------------------------------------------------------------------

// MessageMetadata

// string uuid = 1;
inline void MessageMetadata::clear_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& MessageMetadata::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MessageMetadata.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageMetadata::set_uuid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MessageMetadata.uuid)
}
inline std::string* MessageMetadata::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:MessageMetadata.uuid)
  return _s;
}
inline const std::string& MessageMetadata::_internal_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uuid_.Get();
}
inline void MessageMetadata::_internal_set_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.Set(value, GetArena());
}
inline std::string* MessageMetadata::_internal_mutable_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uuid_.Mutable( GetArena());
}
inline std::string* MessageMetadata::release_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MessageMetadata.uuid)
  return _impl_.uuid_.Release();
}
inline void MessageMetadata::set_allocated_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uuid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MessageMetadata.uuid)
}

// .ApplicationMessageHeader header = 2;
inline bool MessageMetadata::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void MessageMetadata::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ApplicationMessageHeader& MessageMetadata::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ApplicationMessageHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::ApplicationMessageHeader&>(::_ApplicationMessageHeader_default_instance_);
}
inline const ::ApplicationMessageHeader& MessageMetadata::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MessageMetadata.header)
  return _internal_header();
}
inline void MessageMetadata::unsafe_arena_set_allocated_header(::ApplicationMessageHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::ApplicationMessageHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageMetadata.header)
}
inline ::ApplicationMessageHeader* MessageMetadata::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ApplicationMessageHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ApplicationMessageHeader* MessageMetadata::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MessageMetadata.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ApplicationMessageHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::ApplicationMessageHeader* MessageMetadata::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ApplicationMessageHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::ApplicationMessageHeader*>(p);
  }
  return _impl_.header_;
}
inline ::ApplicationMessageHeader* MessageMetadata::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ApplicationMessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:MessageMetadata.header)
  return _msg;
}
inline void MessageMetadata::set_allocated_header(::ApplicationMessageHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::ApplicationMessageHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:MessageMetadata.header)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::MsgType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::MsgType>() {
  return ::MsgType_descriptor();
}
template <>
struct is_proto_enum<::ProtocolMessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ProtocolMessageType>() {
  return ::ProtocolMessageType_descriptor();
}
template <>
struct is_proto_enum<::ResponseEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ResponseEnum>() {
  return ::ResponseEnum_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // mmtp_2eproto_2epb_2eh
